## 动态搜索（Motion Estimation、ME）

![Motion Vectors](files/mpmemc/Motion-Vectors-v2.png)

图：Elephants Dream 视频素材某帧的动态向量分布。来源：[维基百科](https://en.wikipedia.org/wiki/Motion_estimation)

注：它的专业术语是运动搜索、运动估计；具体到视频编码时，要加上“整数像素”的前缀。

在连续帧间画面中，进行运动估计的整数像素精度动态信息搜索步骤，涵盖了各式搜索算法与各样的信号处理用途。具体步骤是以被参考帧内的已编码块（Coded Block）为起点，尝试通过位移来匹配相邻帧的画面，从而找到一个失真最小的向量（Direction of minimal distortion、DMD），这个向量就是整数动态向量。

为了找到可用的最小失真朝向，并且避免进行算力占用巨大的全搜索（Exhausive Search），动态搜索演化出了多种匹配的图案和算法。其中，较为聪明的动态搜索算法是多级算法，它们首会先尝试在较大范围进行粗略搜索，再以大致最佳区域为中心进行精细搜索，从而（包括在噪点干扰下）多快好省地找到整数动态向量。在整数动态搜索之后，还会由子像素动态搜索（Sub-pel Motion Estimation）来进一步做对齐，最终，这个动态向量被用于冗余预测块，以及对高动态画面提高有损压缩强度，从而压缩体积并优化码率的分配。

如果动态搜索的过程有缺失或不够理想，参考帧与分块的建立会变得低效，码率分配也会变得不够合理，导致画质的降低和码率的增加。

注：动态搜索的用途包括计算机视觉的目标跟踪（自动驾驶、监控与制导系统）、基于动态向量的分辨率超采样（如 DLSS）、视频驱动的 3D 建模与插帧、剪辑后期的视频去抖（如 Adobe Premiere 的变形稳定器效果）、智能电视内置的动态画质增强（虽然大多情况下效果一般）等等。

![Interframe-Vector-Table](files/mpmemc/Interframe-Vector-Table.png)

图：宏块上帧间的动态向量

简化模型下，动态搜索得到帧间向量表，帧间向量表加上上帧的画面得到预测帧，原始帧减去预测帧得到残差帧，残差帧储存为参考帧，得到帧间结构。x264 使用了不对称多六边形搜索 Uneven multiple Hexagon，从而让一个搜索算法在多个分辨率下检查画面，制衡了动态噪点对传统动态搜索算法的干扰。搜索算法详见 [x265 教程](../../x265-web-tutorial/HTML/index.html#h2-5)。

`--me`

\<hex/umh/esa/tesa，推荐 umh> 搜索算法，umh 平衡，star 四角星搜索之后收益递减，sea 是优化过的 x264 esa 穷举，但收益递减仍大。umh 通过多种分辨率大小的查找范围，减轻了动态噪点对传统搜索算法的干扰

`--merange`

<整数，推荐 4 的倍数，需 me>完全取决于 ME 算法和分辨率，过大会因「找不到更好，找到也是错」而损失画质和压缩。

- 1920x1080 下推荐48左右
- 3840x2160 下推荐52左右
- me hex 下设16
- me umh 设≥32

`--no-fast-pskip`

<开关，推荐开> 关闭跳过编码 P 帧的功能

`--no-chroma-me`

<开关，推荐直播/录屏用> 跳过色度平面动态搜索，将亮度平面直接应用。可能对画质有略微负面影响

### 绝对变换差和 SATD

Sum of absolute transformed difference 为两个变换块间做差，取和，取绝对值的步骤：

1. 首先计算两个块 B 的插值，记做残差块 D：\\(\text{D}(x,y) = B(x,y) - B\prime(x,y)\\)
2. 然后通过哈达码变换（相比 DCT 节约算力），得到变换残差块：\\(T(D)\\)
   - 省略这一步，则算法叫做绝对差（Sum of absolute difference、SAD）
3. 最后，变换残差块的每个像素取绝对值和：\\(\text{SATD}(B,B\prime) = \sum\_{x=0}^{n-1}{\sum\_{y=0}^{n-1}}| T(D(x,y)) |\\)

注：为了简化所以写作 \\(T(D(x,y))\\)，实际这样相当于每加一个像素值就要变换一遍
