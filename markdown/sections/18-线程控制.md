## 线程控制

### 任务拆分

视频编码会对大量数据进行复杂计算，属于高吞吐量（High throughput）程序，多线程优化在这里包括将编码的大步骤拆分为独立的小操作，例如通过将一个帧拆分为粗分块（宏块）来实现。不过，拆分是有极限的；x264 r1607 前的版本曾有过逐条带（slice，一组宏块）的编码任务拆分，目的是通过大量条带的并行提高编码单帧的速度，降低延迟。但压制后的效果非常差，因为：

1. 熵编码中，CABAC（见 [x265 教程——熵编码](../../x265-web-tutorial/HTML/index.html#h2-15)）因为上下文不连续所以经常重设，效果大打折扣
2. 动态信息的动态向量长度被限制到条带分片内部，干扰动态补偿，降低压缩率
3. 帧内冗余降级为条带内冗余，降低帧内编码压缩率
4. 增加了相当一部分（多余条带与 NAL 封包的）文件头

### 同步与异步

将一个复杂的大步骤拆分，会产生适合同步（Synchronous）与适合异步（Asynchronous）执行的小步骤。例如“打印”这个操作适合异步执行；如果使用同步操作，那么打印时电脑会停止响应，等待打印完成并同步打印结果，再恢复响应，显然是不合适的。在视频编码中，除了前瞻进程（Lookahead）以外，其它的搜索与冗余步骤高度相关，因此，x264 编码器默认会占用 `--threads` 加 `--lookahead-threads`条进程，从而占用一个数量相对合理的线程数。而 `--threads` 达到并超过 16\~24 时，可以看到画质下降一点，以及在更多核心的电脑上出现“吃不满”的问题，这就是 x264 编码特性所致的优化极限了。

### 码率分配均衡程度

故意创建比电脑处理器更多的线程会导致码率增加，画质降低。这是因为 CPU 一次只能运行线程数量的任务，结果就是从数量上冲淡了一些关键步骤所需的“运行占用百分比”，甚至有时等不到就跳过，最终导致了不够合理的码率分配，以及其副作用。

x264 并没有对多路/多 CPU 节点电脑优化，但 [x265 使用线程池](../../x265-web-tutorial/HTML/index.html#h2-18) 实现了。

`--threads`

<整数，建议保持默认（等于 CPU 线程）>由于参考帧步骤要等其之前的步骤算完才开始，所以远超默认的值会因为处理器随机算的特性而降低参考帧的计算时间，使码率增加，画质降低，速度变慢

`--non-deterministic`

<开关，默认关，推荐开> 降低多线程完算性——减少多线程共享数据的可靠性，些微提高画质。使用后每个进程的冗余判断更为独断，且让新的动态搜索线程得知「旧动态搜索线程线程实际搜素过，而非参数设定」的区域。「完算性」一般仅代表通过完整计算得到结果，而不是提前跳过的计算特征。而启用多线程，VBV 都会降低完算性

`--lookahead-threads`

<整数，建议保持默认（应该是 `--threads` 的 1/4）>指定前瞻进程占用的线程数，速度太快则其后的编码进程跟不上，太慢则其后的编码进程要等结果，所以不需要改动

`--frame-threads`

<整数，建议保持默认（自动）>指定 `--threads` 中分配多少线程给编码帧，决定一次同时编码多少帧（量化，优化，帧内预测，熵编码）。剩下则是上下游的处理（连续 B 帧推演，SEI，完算性错误管理），后者占用较少

`--sliced-threads`

<开关，默认关，推荐关>逐条带分配多线程。x264 r1607 前的多线程分配机制，后来因为问题太多而改成了逐帧分配多线程

退一步讲，只要一个程序能吃满全部 CPU 核心，那么多线程优化自然会到位。因此，对于多线程优化一般的程序，只要多打开几个，并限制每个程序的线程数，就能提高最终的效率。例如 [Windows 批处理提供的 `START` 命令实现异步并行（多开些编码）](https://stackoverflow.com/questions/1449188/running-windows-batch-file-commands-asynchronously)，搭配上述的 `--threads` 命令限制每个编码的进程数实现。

x264/5 中，理论画质与性能最平衡的多线程数实际是 4，所以若设定 `--threads 4`，则 `--lookahead-threads` 等于 1。得到共 5 个线程占用。

### x264 内置滤镜

#### 降噪滤镜

`--nr`

<整数 0\~65536，降噪范围 100\~1000，不推荐>当 ABR/VBV 指定了高于 `--qpmax` 或默认最大量化强度时，会调用这个滤镜。如果有降噪需求则建议使用效果更好的外部滤镜工具，或至少使用 `--vf hqdn3d` 滤镜

#### AviSynth 滤镜

`--vf`

\<crop:\[←],\[↑],\[→],\[↓]/pad: \[←],\[↑],\[→],\[↓]/resize:\[宽，高]，\[变宽比]，\[装盒]，\[色度采样]，\[缩放算法/select\_every:步，帧，帧…]/hqdn3d:\[空域 Y 降噪强度]，\[空域 C 降噪强度]，\[降噪时域 Y 强度]，\[时域 C 降噪强度]/yadif\[模式],\[顺序]>裁剪，加边，缩放/更改分辨率，删除/保留视频帧，降噪，色彩空间转换滤镜。例：

- crop:3,4,5,6：视频左，上，右，下分别裁剪 3，4，5，6 个像素
- pad:0,7,8,9,,,255,255,255：视频上，右，下分别加 7，8，9 个像素的 #FFFFFF（白）边
- pad:,,,,1920,1080,1,36,38：视频对称加减边到 1920x1080 像素，若加边则加 #013638（深蓝绿）边
- pad:,,,,3840,2160,,,：视频加减边到 3840x2160 像素，若加边则加 #000000（黑）边
- resize:1060,1080,96:53,,,lanczos：1920x1080 视频的宽使用 lanczos 算法缩小 53/96；同时标记视频宽在播放时，宽度应拉伸 96:53 倍（96:53 长方像素），显示为 1920x1080
- resize:1280,720,,i444,spline：使用样条插值缩放输入视频到 1280x720，储存为 YCbCr 4:4:4
- resize:1060,1080,,width,i420,lanczos：使用 lanzcos 插值，只将宽 width 缩放到 1060px，储存为 YCbCr 4:2:0
- hqdn3d:0,0,3,5：仅开启时域降噪滤镜，分别在 Y，C 平面设定强度 3,5
- vflip：左右翻转视频
- subtitles：在集成 VSFilter64.dll 动态链接库的情况下渲染字幕文件，需`--sub` 导入字幕文件，然后使用 `--vf subtitles` 参数渲染字幕到视频
- select\_every:5,0,1,3,4：视频每 8 帧中留第 1，2，4，5 帧，丢弃第 3 帧
  - AviSynth 中主要用于搭配 IVTC 滤镜使用，但 x264 中没有这些滤镜
- yadif:1,tff：使用 bobbing 算法，上场优先模式将交错视频转为逐行视频

这些滤镜可以在实现简单的画面处理。使用多个滤镜的例子如：`--vf crop:10,0,10,0/resize:640,480,,,,lanczos`。

- resize 中 \[select\_every] 滤镜详见 [AviSynth Wiki](http://avisynth.nl/index.php/Select#SelectEvery)
- resize 中 \[色彩空间] 可用的值有：i400,i420,yv12,nv12,nv21,i422,yv16,nv16,yuyv,uyvy,i444,yv24,bgr,bgra,rgb
- resize 中 \[缩放算法] 可用的值有：fastbilinear,bilinear,bicubic,experimental,point,area,bicublin,gauss,sinc,lanczos,spline
- yadif 是一种简单的交错转逐行滤镜，推荐用画质更好的外部滤镜，见附录 ε：[交错转逐行与 IVTC](../../deint-ivtc-web-tutorial/HTML/index.html)
- x264 中内置的 yadif 滤镜来自 MPlayer，因此参数不同于 AviSynth：
  - yadif 中 \[模式] 可用的值有 0,1,2,3；\[顺序] 可用的值有 tff 和 bff
- hdqn3d 是一种简单快速的时域 + 空域降噪滤镜。仅指定 `--vf hqdn3d` 则使用默认强度（仅开启滤镜）为 4,3,6,4.5

`--sub`

<路径到文件，需 `--vf subtitles` 和 VSFilter64.dll>见 `--vf subtitles` 说明

联系： [Github](https://github.com/iAvoe/)， [Github Issues](https://github.com/iAvoe/x264-web-tutorial/issues)， [QQ 群：691892901](https://jq.qq.com/?_wv=1027\&k=5YJFXyf)

教程地图、工具下载： [iavoe.github.io](https://iavoe.github.io/)

Ⓒ iAvoe，2025
