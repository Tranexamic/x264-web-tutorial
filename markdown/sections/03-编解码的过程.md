## 编解码的过程

注：实际情况下会因为软硬件，用户设定，以及操作系统逻辑的不同而变。

### 视频的打开

1. 用户点击打开视频文件
2. 操作系统根据文件扩展名，查找默认的应用程序
3. 应用程序根据文件路径，在文件系统中定位视频，并读取文件的元数据，包括文件头和其他格式信息
4. 应用程序根据文件的元数据确定所需的解码器和其他资源，然后在计算机的内存中分配空间
5. 应用程序调用适当的解码器来解析视频文件，并将视频和音频数据解码为未压缩的原始数据
6. 解码后的视频数据传递给图形处理芯片 GPU，而音频数据则传递给声音转换芯片 DAC。
7. GPU 将图像信号转换为图像，输出到显示器
8. 显示器上的芯片将图像数据转换为对每个像素上电路的控制，并显示出来
9. DAC 将音频信号转换为模拟信号，并通过扬声器播放出来

### 视频的压制

1. **打开编码器**

   - 用户可以通过多种方法打开编码器：

     - 如果编码器内置了如 Lavf 的解封装和解码动态链接库，则编码器可以自动解封装、解码和封装视频文件：

       - GUI 软件通过发送 CLI 命令，或者使用像 Bash/CMD 这样的 CLI 工具来打开编码器程序。
       - 编码器通常根据输出文件的后缀名自动封装视频文件。

     - 如果编码器没有内置解封装解码功能，则通常会使用 ffmpeg 内部的解封装工具和编码器。
       - 可以使用 pipe 将上游如 ffmpeg、VapourSynth、avs2yuv 连接到下游如 x264/5 的编码器

2. **解封装和解码**

   - 解封装解码工具将已解压缩的 YUV for MPEG 或 RAW 格式视频流传递给编码器，编码器得到输入信号。

     - 如果输入是 RGB24 的 RAW 色彩空间视频流，通常需要使用编码器内置的色彩空间转换功能将其转换为 YUV 格式。
     - 如果编码器是录像设备的一部分，则需要根据录像设置将视频流拆分为视频帧。

3. **编码过程**

   - **前瞻进程（Lookahead）**：预先分析未来几帧的复杂度、运动和场景切换 scenecut 的估计、I-P-B 帧类型决策
     - 帧类型决策由最短路径算法（Shortest Path）确立

   - **粗分块**：虚拟步骤，编解码器直接根据指定可用的大小开始在特定位置上操作，因此搜索等操作默认这步已经完成

     - x264：宏块 Macroblock MB（16x16）
     - x265：编码树单元 Coding Tree Unit CTU（最大 64x64、最小 32x32）
     - AV1：特大块 Superblock（最大 128x128，但为了兼容现有硬编硬解、所以很多步骤上等效于 64x64）

   - **动态搜索**：Motion Estimation（ME）找到当前帧与参考帧之间的相似区域，并为每个块分配动态向量。

   - **运动补偿**：Motion Compensation（MC）对比实际画面与搜索到的向量生成预测块，并补偿¼子像素精度的对齐偏差。

   - **细分块**：根据 MEMC，进一步细分宏块或编码树单元到最小的 4x4 编码块上。

   - **帧间残差编码**：对比实际画面与动态搜索与补偿后所得的图像，得到残差，并对残差进行变换和量化，存储到 P-B 帧上，在解码时与 I 帧叠加以得到原始画面。

   - **帧内预测**：在帧内编码块上检查候选出冗余最好的帧内编码方法（夹角、DC、趋平、无），选中方法后得到帧内预测后的块，即预测块。
     - 开启率失真优化则进一步检查画质同码率下画质是否也最好

   - **帧内残差编码**：对比实际画面与帧内预测得到的残差块，进行变换和量化，存储在预测块中，在解码时与预测模式叠加以得到原始画面。

   - **跳过块编码**：跳过帧间或帧内残差编码的块，进行变换和量化。

   - **变换**：将图像从空间域转换到低频到高频信号分量之间的每个级别，也称为频域。

   - **量化**：根据用户设置的质量级别，削减高频信号分量，这一步骤对画质和文件大小影响最大。

   - **熵编码/文本编码**：将变换和量化后的频域分量统计为最小可能的二进制数。

4. **生成视频流**

   - 编码器将生成的数据流逐个 GOP Group of Pictures 打包为文件，得到完整视频流文件
   - 如有必要，附加如色彩空间、Supplemental Enhancement Information SEI、VUI、HDR 等元数据

5. **封装视频流**

   - 用户可以通过多种方法将视频流封装为 .mp4、.mkv、.mov 等格式：

     - 如果编码器内置了像 Lavf 的解封装解码动态链接库，编码器可以根据输出命令行的文件后缀名自动完成。
     - 如果编码器没有内置解封装解码功能，则通常会使用 ffmpeg 内部的编码器和解封装工具，使编码完成后自动封装。
     - 可以使用工具如 [ffmpeg](http://ffmpeg.org/download.html)、[MP4Box](https://www.videohelp.com/software/MP4Box)，[MKVToolNix](https://mkvtoolnix.download/) 等来进行封装。

   - 封装文件使得播放器的程序逻辑变得简单（例如，在读取视频流之前就获取视音频格式，而不是先打开所有解码器，再关掉不兼容的解码器）

   - 如有必要，附加音频流/音轨、字幕轨、字体等文件（但要根据封装文件的兼容性判断）

![Video-Endocing-Process](files/basics/Video-Endocing-Process.png)

### 视频编码的标准（[MDN Docs](https://developer.mozilla.org/en-US/docs/Web/Media/Formats/Video_codecs)）

Encoding Standard 一般称为 Codec。

| ♙编码          | 全称                            | 一般封装格式             |
| ------------ | ----------------------------- | ------------------ |
| AV1          | AOMedia Video 1               | MP4，WebM，MKV       |
| AVC (H.264)  | Advanced Video Coding         | 3GP，MP4            |
| H.263        | H.263 Video                   | 3GP                |
| HEVC (H.265) | High Efficiency Video Coding  | MP4                |
| MP4V-ES      | MPEG-4 Video Elemental Stream | 3GP，MP4            |
| MPEG-1       | MPEG-1 Part 2 Visual          | MPEG，QuickTime     |
| MPEG-2       | MPEG-2 Part 2 Visual          | MP4，MPEG，QuickTime |
| Theora       | Theora                        | Ogg                |
| VP8          | Video Processor 8             | 3GP，Ogg，WebM       |
| VP9          | Video Processor 9             | MP4，Ogg，WebM       |

其中，“H.264”的 H 代表国际电信联盟——电信标准化部门（ITU‑T）中的 [H 系列建议指南](https://www.itu.int/net/itu-t/sigdb/spevideo/Hseries-s.htm)，例如 [ITU-T H.810](https://www.itu.int/rec/T-REC-H.810) 个人健康系统（血压计、血糖仪、体重秤）的交互设计建议指南。一些符合某个 H 系列视频编码建议指南的视频编码器会将这个标号写在程序名字上，就有了所谓的 x264，x265。

![Video-Endocing-Standards](files/basics/Video-Endocing-Standards.png)

### 命令行参数

由开发者定义，将函数或程序中的一些变量设为通过命令传递。命令行参数一般使用空格作为分隔符（也有用半角冒号，半角句号等其他情况），参数和参数值之间一般使用空格做分隔符（也有使用等于号的其他情况），多个参数值之间一般使用半角逗号或半角冒号分隔，而含有空格的参数值则使用半角直引号 "" 或 '' 连起来。

例如，x264 使用 CLI 参数的例子：

`x264.exe --rc-lookahead 90 --bframes 12 --b-adapt 2 --me umh --subme 9 --merange 48 --no-fast-pskip --direct auto --weightb --keyint 360 --min-keyint 5 --ref 3 --crf 20 --qpmin 9 --chroma-qp-offset -2 --aq-mode 3 --aq-strength 0.7 --trellis 2 --deblock 0:0 --psy-rd 0.77:0.22 --fgo 10 --nr 4 --output ".\输出.mp4" ".\导入.mp4"`

以及 ffmpeg 中使用 CLI 参数启用 libx264，通过 `-x264-params` 发送 API 参数的例子：

`ffmpeg.exe -loglevel 16 -hwaccel auto -y -hide_banner -i ".\导入.mp4" -c:v libx264 -x264-params "rc-lookahead=90:bframes=12:b-adapt=2:me=umh:subme=9:merange=48:fast-pskip=0:direct=auto:weightb=1:keyint=360:min-keyint=5:ref=3:crf=20:qpmin=9:chroma-qp-offset=-2:aq-mode=3:aq-strength=0.7:trellis=2:deblock=0,0:psy-rd=0.77,0.22:nr=4" -fps_mode passthrough -c:a copy ".\输出.mp4"`

ffmpeg 中，导入文件由 `-i` 参数完成，因为 ffmpeg 支持导入多个文件，而每个文件后跟随一些处理命令就需要较为严格的命令添加顺序，而 x264/5 这些编码器一般只是导入一个文件，所以在末尾加一个路径到文件的字符串就代表导入文件了。

![Encoding-CLI-Info](files/basics/Encoding-CLI-Info.png)

图：使用命令行窗口启动视频压制命令后，视频编码器会给出大致这些信息

### 本教程中命令行参数的说明格式

`--参数`

<开关 | 整数 A\~B | 浮点 A\~B | 其它格式，默认值，限制>说明信息，特点注解，推荐这个值，其它情况可设这个值。

- 情况 1：特点如此，推荐这个值
- 情况 2：特点如此，推荐这个值

### 管道（Pipe）

一种在进程/软件之间通信的操作系统机制。在命令行中写作通过链接符 | 串联起来是两段命令，而两段命令间的数据一般由默认输出 standard output（stdout）和默认输入 standard input（stdin）实现，因此不需要手动添加输出和输入命令。报错则为 stderr。在涉及到文件输入输出的程序时则需要手动指定“-”符号到程序的输入命令中，以取代文件的输入。

#### 串流管道 Stream-based pipe

Windows CMD、Linux Bash 的管道模式，用于传输纯数据，其中的程序同步运行，持续地传输上游输出到下游。适用于串流作业和处理流数据，包括视音频和文本流。

##### 串流管道详解

Linux Bash 中使用 `for txt in *.txt; do md5sum $txt; done | awk '{print $2, $1}' | sort -bn` 代表：

- 在当前命令行目录下遍历 .txt 文件，生成多行“哈希值 文件名”字符串
- 将文本流传给排列功能，将每行字符的顺序改为“文件名 哈希值”
- 将文本流传给排序功能，按照文件名的数字重排行号并忽略空格，得到按顺序排版的“文件名 哈希值”

#### 对象管道（Object-based pipe）

PowerShell 的管道模式，用于传输结构化的对象（变量本身），而不是纯数据。其中的程序按顺序接力，一个程序/协议/函数跑完后再打开下一个。适用于处理对象化数据（面向对象的应用），所以不适合用于处理视音频流文件。

#### 指定默认输入和报错

`J:\ffmpeg.exe -i D:\文件夹\源.mp4 -an -f yuv4mpegpipe - | J:\x264-r3206.exe --y4m - --output D:\文件夹\测试.h264 2> D:\文件夹\报错.txt`

以上命令代表在 Windows CMD 中：

1. ffmpeg 导入 "D:\文件夹" 下的一个视频文件
2. ffmpeg 使用 `-an` 命令指定关闭音频编码
3. ffmpeg 使用 `-f` 命令指定使用 YUV For MPEG 管道格式，相对于 rawpipe 格式提供了一些视频元数据，使 x264 了解视频的分辨率、帧率、位深等基本参数，否则需在命令行中手动指定
4. ffmpeg 使用“-"替代文件路径，指定导出文件到管道
5. x264 使用 `--y4m -` 命令指定使用 YUV For MPEG 管道格式，并设定输入流为“-”
6. x264 导出压制出、未封装的视频流到 `D:\文件夹` 下
7. x264 导出任何可能的报错信息到 `D:\文件夹` 下，以避免管道上游的信息覆盖或埋藏

#### 管道的问题与上位替代

- 管道下游程序的报错常被管道上游覆盖或埋藏，需要额外指定报错信息导出路径
- 虽有编程爱好者集成 LAVF 编解码到 x264 编码器中（封装、解封装视频流功能），但不是所有视频编码器都受到这种待遇
- 视频流已经占据了管道，音频流的封装就需要等第二行命令实现了
- 同理，若视频编码命令出错，那么自动化脚本中的封装命令也会失败，使得原本的报错信息更难找到

而上面的命令可以被简化到直接调用 ffmpeg 内置的 libx264 库，从而用一条命令实现压制与封装：

`J:\ffmpeg.exe -i D:\文件夹\源.mp4 -c:v libx264 -fps_mode passthrough -c:a copy D:\文件夹\输出.mp4`

这种命令行环境下，要注意音频流与封装格式的兼容性。如果要替换或添加新音频轨道，则在 ffmpeg 命令行中输入音频流，并通过 `-map`、`-c` 命令指定替换或添加。
