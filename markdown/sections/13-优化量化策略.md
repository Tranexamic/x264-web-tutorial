## 优化量化策略

### 率失真优化 Rate distortion optimization（RDO）

视频压缩策略受到算力、分析算法、客户等诸多限制。尽管工程师和开发者付出了很多努力，最后也往往回归最直接的“码率越小越好”——给所有压缩步骤选择码率最小的编码模式，或者强行上马一个 CQP 就完事。这样做的结果是码率分配失衡，即“码率在握之画质全损”，而“码率在握”也只是因为作对比的是无损或未压缩视频源；实际上，如此“粗压”与“精压”相比还会露馅——后者在画质更高的情况下，码率往往更低。原因是*过度的有损压缩使得本可用于无损压缩（冗余）的机会被因小失大地浪费*。例如，过度的量化会破坏 P-B 帧原本可以参考 I 帧的部分，由于差异太大，编码器只得放弃参考，把这个区域重编码为 I 块，或直接改成 I 帧。

现代视频编码器已经具备了减免这种问题所需的信息——编码后失真、码率代价，以及编码后码率。将失真，码率分别看做两种“越大越差”的程度，再根据码率代价——“此处码率的宝贵程度”缩放出一个一元一次函数空间（\\(y = mx + b\\)），问题就迎刃而解——只要找到各种 \\(mx+b\\) 里最小的 \\(y\\) 即可，而“找到最小”的过程需要统计每个编码步骤下的多个至全部编码模式，这个过程就是率失真优化（RD）。率失真优化的性能占用虽然不小，但它带来的好处可以和动态搜索相媲美。

“编码器策略”就是模式决策。率失真程度由代价函数「开销 = 失真+λ⋅码率」（越小越好）得出：

\\\[J = D + \lambda \cdot R\\]

编码器在决定采用哪种编码模式（如帧内/帧间、哪种块划分、运动矢量朝向等）时，不再只考虑码率 R 或失真 D，而是计算所有候选模式的率失真代价 \\(J = D + \lambda R\\)，然后选择代价 J 最小的那个模式。

- \\(\lambda=0\\)：无斜度，则代价等于失真——码率变而画质不变，宜压缩
- \\(\lambda \rightarrow 0\\)：趋 0，则开销趋失真——宜适当压缩
- \\(\lambda >0\\)：大于 0，则开销大于失真——保画质收益大于压缩收益，宜保画质

![x264-JM-RDO-Lambda](files/rate-distorsion-optimization/x264-JM-RDO-Lambda.png) ![RDO-Lambda-Slopes](files/rate-distorsion-optimization/RDO-Lambda-Slopes.png)

图：率失真优化中λ的斜度变化与效果

![RDO-qStep-Chart](files/rate-distorsion-optimization/RDO-qStep-Chart.png)

图：率失真表格中不断调整并得到“×”的实际效果

`--fgo`

<整数默认关，推荐 15 左右>将高频信号在量化前后的差距也算进率失真优化的统计中，使优化更倾向于保留细节和噪声

### 心理视觉优化

Psycho-visual optimization PVO 更类似于一种自适应量化，利用人类视觉系统的特性，通过掩蔽和感知量化量化，实现低码画面的码率再分配，保持高压缩的同时，提供更好的主观视觉质量。主观质量是建立在损失客观质量（与输入源的差距）上的质量。

1. **空间掩蔽（Spatial Masking）**：
   - 人眼会忽略高锐度边缘周边区域的画面，因此增加这些区域的量化强度
2. **频域掩蔽（Frequency Masking）**：
   - 人眼会忽略高频细节区域内的低频信号分量，因此可以在变换块中剔除高频块的低频分量

`--psy-rd`

<α:β 浮点，默认 1:0>心理学优化设置。α 保留纹理，β 在 α 的基础上保留噪点细节。画质优先时，α、β 值的大小与画面复杂度呈正比，但增加的程度相比于画面复杂度应该更小。

- 低成本动漫与幻灯片录屏画面：0.4:0.1\~0.6:0.15
- 电影，录像等场景：0.7:0.12\~1.3:0.2
- `--no-mbtree` 时，可将 β 设置为 0

`--no-psy`

<开关>若视频量化很低，纹理清楚，没有优化的必要可以关。但大部分情况下不应该关，而是用较低的优化强度

![Principle-on-Image-Quality](files/rate-distorsion-optimization/Principle-on-Image-Quality.png)

图：心理视觉优化保留高频信号，同时压缩周围和其中的非高频信号

### 宏块树与量化值曲线缩放 qComp

源自 libavcodec 实现同码率下整体画质更高结果的逻辑：“复杂动态场景的帧间参考少。所以分配更少码率（增加量化压缩），更多码率应该分给参考多而远的简单动态场景”。这样做在码率受到很大限制时能保护多数场景的画质，但缺点则是大多时候，动漫场景等「背景不动前景动」的场景（如人物脸部）画面被压缩太多的问题。x264 中所做的改进是“逐宏块应用这套逻辑”——即 [MarcoBlock Tree (MBTree)](https://web.archive.org/web/20150224032942/http:/x264dev.multimedia.cx/archives/98)。量化值曲线缩放 quantizer curve compression 则被“贬为”控制 MBTree 等一系列量化强度分配算法中的一个缩放参数，见 [desmos 互动例](https://www.desmos.com/calculator/aa7rsjuxkr)。

#### qComp 的用途

1. （ABR 模式）根据宏块的数量与 `--qcomp` 值设置初始复杂度百分比： \\\[ \text{Complexity} = \left( \frac{\text{Count}\_{MB}}{2} \right) ×700000^{\left( \frac{qcomp}{100} \right)} \div 100 \\]
2. 获取当前场景的长度 \\( \text{Duration}\_{clip} \\)
3. 当前帧与下一帧间的图像模糊后做 SATD，获得「模糊复杂度 \\( \text{Complexity}\_{blurred} \\)」

- （关 MBTree 时）使用 `--qcomp` 缩放模糊复杂度，以换算出当前帧的 qScale： \\\[ \text{qScale} = \left( \text{Complexity}\_{blurred} \right)^{1-qcomp} \\]
- （开 MBTree 时）据 I 帧在当前片段的权重设单帧量化强度（基准单帧用时 ÷ 当前场景用时 × I 帧用时 ÷ 帧率）： \\\[ \text{qScale} = Duration\_{frame} \div Duration\_{clip}\times Duration\_{iframe} \div \text{fps} \\]

`--qcomp`

<浮点范围 0.5\~1，推荐默认 0.6>模糊复杂度 `cplxBlur` 以及宏块树迭代每帧量化强度范围的曲线抑制参数。越小则复杂度迭代越符合实际状况，抑制 CRF，宏块树/CU 树（MBTree/CUTree），bframes 影响的效果就越弱，搭配高 CRF 能使码率控制接近 VBV 的程度。越大则 CRF，mb-cutree，bframes 越没用，越接近 CQP

- 小于 0.5，中\~强 MBTree CRF/ABR低延迟逐帧迭代qp; 画面主前景动时用，允许宏块树导致零星宏块欠码
- 0.5\~0.7 中 MBTree CRF/ABR中延迟逐帧迭代qp, 画面含背景动，或混合情况用，平衡优先
- 大于 0.7 中\~弱 MBTree CRF，ABR 中到高延迟逐帧迭代量化强度，保留重噪点，或 FPS/STG 游戏录屏场景用
- 小于 0.5 关 MBTree 画面不分前背景，如静态图像，PPT/桌面录屏节约性能用
- 大于 0.5 关 MBTree 动态画面，不分前背景时节约性能用
- 0（if 判定）启用固定码率模式
- 1（if 判定）启用固定量化强度模式

#### 宏块树 Macroblock-Tree/帧间逐宏块自适应量化

宏块的构成可以被视作“帧间预测 + 帧内预测 + 预测残差”三张图。如果宏块的绝大多数内容数据（如 70%）来自于帧间预测，而这个宏块里当前 GOP 末尾（关键帧间隔 `--keyint`）很近了，那么它的出现时间自然是配不上它的码率的。如果找出并降低这种宏块的码率（指定该宏块的量化值/量化强度 +N），省下来的码率分给 GOP 开头和中间的宏块，码率的分配就更均衡，整个视频的画质都会提升了。宏块树就是实现这种码率分配优化的算法，本质上这是一种时间域的逐宏块自适应量化，且在现代视频编码中被重用。详见 [x264 率控制算法](http://lazybing.github.io/blog/2021/06/22/h264-rate-control-algorithm/) 及 [MBTree 论文](<https://huyunf.github.io/blogs/2017/12/06/x264_slice_type_decision/MBtree paper.pdf>)。

由于宏块树的步骤位于前瞻进程（Lookahead）中，而前瞻进程位于动态搜索和运动补偿之前，且前瞻进程只使用半分辨率的视频帧，因此，此时的宏块树会额外尝试一些简单的帧内和帧间预测。

注：帧间参考代价只能小于等于帧内参考代价，类似于（同视频下的）P 帧体积不应大于 I 帧；若出现帧间参考代价大于帧内参考代价的情况，就重设为「帧间参考代价等于帧内参考代价」

宏块帧内和帧间的参考代价记为 \\(\text{Cost}\_{intra}\\) 和 \\(\text{Cost}\_{inter}\\)，通过前瞻进程（Lookahead）中以下“搜索”步骤得到：

- **简单帧内预测/宏块自身信息量预测：**&#x5C1D;试水平和垂直模式

  - 水平模式：得到残差为 2，代价为 4
  - 垂直模式：得到残差为 3，代价为 5
  - 选择水平模式，记 \\(\text{Cost}\_{intra}\\) 代价为 4

- **简单帧间预测/宏块参考信息量预测：**&#x4EE5;上一帧为参考，进行运动估计

  - 运动矢量 (1,1)：得到残差为 1，代价为 2
  - 运动矢量 (2,2)：得到残差为 2，代价为 3
  - 选择运动矢量 (1,1)，记 \\(\text{Cost}\_{inter}\\) 代价为 2

- **宏块总代价：**&#x81EA;身代价 + 上一帧帧间预测代价 \\( \text{Cost}\_{intra} + \text{Cost}\_{inter} \\)
  - **上一帧帧间预测代价：**&#x4E0A;一帧的宏块与当前帧宏块匹配帧间预测模式所得的代价

- **溯块总代价：**&#x81EA;身代价 + 下一帧帧间预测代价 \\( \text{Cost}\_{intra} + \text{Cost}\_{propagate} \\)

  - **下一帧帧间预测代价：**&#x4E0B;一帧的宏块与当前帧宏块匹配帧间预测模式所得的代价 + \\(\text{Propagate}\_{amount}\\) 累积的代价
  - 由于 B 帧是双向参考帧，所以不存在「上/下一帧帧间预测代价」，而是「参考帧/被参考帧间预测代价」

1. **设定：**&#x5404;个宏块自身代价与参考代价的比率，再从 100% 减掉这个比率，得到给其他宏块参考的信息比率 \\\[ \text{propagate}\_{fraction}=1-\left(\frac{\text{Cost}\_{intra}}{\text{Cost}\_{inter}}\right) \\]

2. **设定：**&#x5404;个宏块内容传播给下游宏块的代价 = 给其他宏块参考的信息比率 × 溯块总代价 \\\[ \text{Propagate}\_{amount} = \text{Propagate}\_{fraction} \times (\text{Cost}\_{intra} + \text{Cost}\_{propagate}) \\]

   - \\( \text{Propagate}\_{fraction} \\) 越小，传播到下游宏块的信息量就越少
   - \\( \text{Cost}\_{intra} + \text{Cost}\_{propagate} \\) 越大，传播到下游宏块的信息量就越大

3. **计算：**&#x4ECE;最远范围 `--rc-lookahead` 开始，从远到近地累积所有宏块的 \\( \text{Propagate}\_{amount} \\)，作为统计列表中下一个宏块的 \\( \text{Cost}\_{propagate} \\)

   - 这里非常绕，总之就是「传播到下游宏块的信息量 \\( \text{Propagate}\_{amount} \\)」是持续更新累积的过程，而不是从当前帧往后查找传播了多少信息
   - 如果出现动态位移（当前宏块的范围被切分到下帧的 4 个宏块之间时），这 4 个宏块会各自按比例拆分出各自的传播信息量

4. **分配：**&#x4ECE;最远范围 `--rc-lookahead` 开始，从远到近地根据已有的 \\( \text{Cost}\_{propagate} \\) 和自身的信息量 \\( \text{Cost}\_{intra} \\)，通过 \\( \log\_{2}() \\) 非线性地映射到量化强度，得到宏块树中每个宏块的量化值偏移： \\\[ \Delta \text{QP} = -\text{strength} \times \log\_{2}\left( \frac{\text{Cost}\_{intra}}{\text{Cost}\_{propagate}} \right) \div \text{Cost}\_{intra} \\]

大部分情况下宏块树偏移的量化强度为零，因为宏块没有参考溯块信息可用。

`--rc-lookahead`

<帧数量，范围 1\~250，推荐 keyint÷2> 指定 cutree 的检索帧数，通常设在帧率的 2.5\~3 倍。高则占用内存增加延迟，低则降低压缩率和平均画质。

注：MBTree/cutree 会自动选择 `--rc-lookahead` 和 \\( \max\left( \text{keyint}, \max\left( \text{vbv-maxrate}, \text{bitrate}\right)\div\text{vbv-bufsize} \times \text{fps} \right) \\) 中最小的值作为检索帧数

`--no-mbtree`

<开关>关闭宏块树/CU 树（MBTree/CUTree）/帧间自适应量化，不推荐。
