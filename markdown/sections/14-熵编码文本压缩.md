## 熵编码/文本压缩

完整的熵编码流程见 [x265 教程网页版——熵编码](../../x265-web-tutorial/HTML/index.html#h2-15)。

### 霍夫曼编码（Huffman Coding）

曾经广泛应用于数据压缩的算法，虽然没有被用于 AVC，但目的相同，此处用于替代说明 x264 中高度复杂的 CABAC 算法。步骤分为：

1. **统计频率**：
   - 在第一次遍历文本/pass1 时，只统计每个字符出现的次数，并按出现频率从小到大排序

2. **构建初始节点**：
   - 将每个字符和其出现频率作为一个节点，并将这些节点放入一个最小堆（优先队列）

3. **构建霍夫曼树**：

   - 从最小堆中取出两个频率最小的节点
   - 创建一个新节点，其频率是这两个节点频率之和，将这两个节点作为新节点的子节点
   - 将新节点插回最小堆中
   - 重复上述步骤，直到堆中只剩下一个节点，这个节点就是霍夫曼树的根节点

4. **生成编码**：
   - 通过遍历霍夫曼树，为每个字符生成霍夫曼编码。通常向左的节点表示为向 0，向右的节点表示为向 1

#### 霍夫曼编码的例子

来源：[geekforgeeks——greedy3](https://www.geeksforgeeks.org/huffman-coding-greedy-algo-3/) 算法。假设第一次遍历文本得到了如下字符及其频率：

| 字符 | 频率 |
| -- | -- |
| A  | 5  |
| B  | 9  |
| C  | 12 |
| D  | 13 |
| E  | 16 |
| F  | 45 |

1. **统计频率**：已完成

2. **构建初始节点**：
   - 据出字次数从小到大排序：(5,'a'),(9,'b'),(12,'c'),(13,'d'),(16,'e'),(45,'f')

3. **构建霍夫曼树**：

   1. 取出字次数最小的两个元素 (5, 'a'), (9, 'b')，合为 (14, 'ab')

      - 得 (12, 'c'), (13, 'd'), (16, 'e'), (45, 'f'), (14, 'ab')
      - ![huffman-coding-1](files/huffman-coding/1.png)

   2. 取出字次数最小的两个元素 (12, 'c'), (13, 'd')，合并为 (25, 'cd')

      - 得 (14, 'ab'), (16, 'e'), (45, 'f'), (25, 'cd')
      - ![huffman-coding-2](files/huffman-coding/2.png)

   3. 取出字次数最小的两个元素 (14, 'ab'), (16, 'e')，合并为 (30, 'abe')

      - 得 (25, 'cd'), (45, 'f'), (30, 'abe')
      - ![huffman-coding-3](files/huffman-coding/3.png)

   4. 取出字次数最小的两个元素 (25, 'cd'), (30, 'abe')，合并为 (55, 'cdeab')

      - 得 (45, 'f'), (55, 'CDEAB')
      - ![huffman-coding-4](files/huffman-coding/4.png)

   5. 取出字次数最小的两个元素 (45, 'f'), (55, 'cdeab')，合并为 (100, 'fcdeab')

      - 得 (100, 'FCDEAB')
      - ![huffman-coding-5](files/huffman-coding/5.png)

4. **生成编码**：
   - 从霍夫曼树根节点开始，为每个字符生成霍夫曼编码：

| 字符 | 编码      |
| -- | ------- |
| F  | 0       |
| C  | 1-0-0   |
| D  | 1-0-1   |
| A  | 1-1-0-0 |
| B  | 1-1-0-1 |
| E  | 1-1-1   |

熵编码是一种无损压缩（例如代码和小说都是文本，文本编码不可更改其内容）。因此，不同的熵编码算法之间就只有编码速度和压缩率两个判断标准。

`--no-cabac`

<开关，不推荐>关闭 CABAC，使用 CAVLC
