<!DOCTYPE html>
<html lang='zh-hans'>
	<head>
        <meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="initial-scale=1">
        <!-- Basic Bootstrap Javascript <script src="./files/bootstrap.min.js"></script> -->
        <!-- Bootstrap CSS <link rel="stylesheet" href="./files/bootstrap.css"> -->
        <!-- Bootstrap Icons CSS (remote)
            <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.5.0/span/bootstrap-icons.css" crossorigin="anonymous">
        -->
        <!-- JavaScript Codes -->
        <script src="./files/tutorial.js" defer></script>
        <!-- Basic MathJax Javascript -->
        <script src="./files/mathJax3-tex-svg.js" defer></script>
        <!-- Custom CSS Codes <link rel="stylesheet" href="./files/desktopContainer.css"> -->
        <link rel="stylesheet" href="./files/tutorial.css">
        
        <title>x264 教程 HTML 完整版</title>
	</head>
	<body class="text-gray-main">
        <div class="px-1 mb-3">
            <h1>x264 教程<span class="text-blue-emph"> HTML 完整版</span></h1>
            <p>欢迎阅读！本教程仅算盲人摸象的业余分析，仅具备业余参考价值。若有什么不会的可以加群<a href='https://jq.qq.com/?_wv=1027&k=5YJFXyf'>691892901</a>。<span class="text-red-emph">点击图片即可更改桌面和移动端的适配排版</span>。</p>
        </div>
        <div class="container-mobile rounded-9 border-main">
            <h2 id="h2-1">必备常识</h2>
            <h3>封装与解封装 - Multiplex/De-multiplex</h3>
            <ul class="overflow-auto">
                <li>文件格式中，类似于 .zip .rar 文件将多个文件（视频，音频，字幕，字体）合并为一个文件</li>
                <li>信号处理中，电台将多路音频流封装为一段模拟信号，接收端通过调整接收频率来接收其中一路信号，每路信号占据一定的频宽/带宽</li>
                <li>视频封装文件记录播放所需的元数据，如视频帧率、音视频同步、色彩标识等：
                    <ul class="text-gray-side overflow-auto">
                        <li><span class="text-blue-emph">MP4</span> 是最常见的格式，适用于网站和本地播放，但对字幕文件的支持性较差。</li>
                        <li><span class="text-blue-emph">MKV</span> 可以封装几乎所有已知的视频/音频/字幕格式，但无法直接导入视频编辑软件</li>
                        <li><span class="text-blue-emph">FLV</span> 是一种轻量级封装格式，更适合网站播放，以及需要定时切分录制的格式。</li>
                        <li><span class="text-blue-emph">MOV</span> 是由苹果公司开发，用于与其软件和硬件兼容，也是 Adobe Premiere 剪辑软件最适用的格式之一</li>
                        <li><span class="text-blue-emph">M4A</span> （MPEG for Audio）是一种音频流封装文件，支持多种音频流，封面图片，详细艺术家，乐队信息元数据封装的格式</li>
                        <li><span class="text-blue-emph">M3U</span> 由苹果公司研发，用于在线播放音频的封装（然后被用于视频封装），M3U8 指 UTF-8</li>
                    </ul>
                </li>
            </ul>

            <h3>元数据 Metadata</h3>
            <p>描述数据的数据，例如食品包装上的标题、成分表、图片、营养信息、教你如何正确打开包装的附注就是一种元数据。视音频封装文件中的元数据并不是视音频本身，但播放器需要其中的一些信息才能以正确的帧率、音视频对齐、色彩标准，使用正确的视频解码器，音频解码器，以正确的打开“包装”。</p>

            <h3>编解码</h3>
            <ul class="overflow-auto">
                <li>编码 Encoding：是数据格式的转换。压缩是编码的一种形式</li>
                <li>解码 Decoding：是将被压缩的信号还原或播放的解压缩。一般来说，压缩程度越高，解码速度越慢</li>
                <li>软解 Software Decoding：使用通用电路播放流文件，通常具有更高的兼容性，更高的能耗/发热</li>
                <li>硬解 Hardware Decoding：使用专用电路替代软解，通常具有更低的兼容性，更低的能耗/发热
                    <ul class="text-gray-side">
                        <li>例如：libmxv，opencl，MMAL，direct3D</li>
                    </ul>
                </li>
                <li>软编 Software Encoding：使用通用电路编码流文件，通常具有更完整的压缩功能但速度较慢，能耗/发热较高，同码率下的画质比硬编更高</li>
                <li>硬编 Hardware Encoding：使用专用电路编码流文件，通常具有较少的功能但速度更快，发热更低
                    <ul class="text-gray-side">
                        <li>例如：NVENC，MMF/Venus，Intel-QSV，Conexant，elgato</li>
                    </ul>
                </li>
                <li>由于编解码器的复杂性，软硬编解码方案在相同价格下存在较大差异，因此最终取决于预算、速度和画质要求</li>
            </ul>

            <h3>数据大小单位</h3>
            <div class="overflow-auto">
                <ul>
                    <li>bit（比特）：最小的计量单位，<span class="text-blue-math">\(1 \text{bit} = \frac{1}{8} \text{Byte}\)</span>，衡量传输流量</li>
                    <li>Byte（字节）：<span class="text-blue-math">\(8 \text{bit} = 1 \text{Byte}\)</span>，衡量文件大小</li>
                    <li>kilo-bit（Kb，千比特）：1000 比特</li>
                    <li>kilo-Byte（KB，千字节）：1000 字节</li>
                    <li>mega-bit（Mb，兆比特）：1000<sup>2</sup> 比特，或 1024<sup>2</sup> = 1048576 比特</li>
                    <li>mega-Byte（MB，兆字节）：1000<sup>2</sup> 字节，或 1024<sup>2</sup> = 1048576 字节</li>
                    <li>giga-bit（Gb，吉比特）：1000<sup>3</sup> 比特，或 1024<sup>3</sup> = 1073741824 比特</li>
                    <li>giga-Byte（GB，吉字节）：1000<sup>3</sup> 字节，或 1024<sup>3</sup> = 1073741824 字节</li>
                </ul>
            </div>
            <div class="align-items-center">
                <img src="files/basics/Data-Sizes.png" alt="image1" class="img-medium" >
                <p class="text-gray-side mt-0">图：比特，字节与体积时间比的转换</p>
            </div>

            <h3>码率/比特率 Bitrate</h3>
            <p>文件体积每秒，单位 bps，Bps，Kbps，KBps，Mbps，MBps，Gbps，GBps 等。“ps”即 per second，也可写作“Kb/s，Mb/s”等。</p>
            <ul>
                <li>长 1 分钟，10MB 大小的视频文件的平均码率为<span class="text-blue-math">\( (10 \div 1 \times 60) \times 8 \text{bit} = 1333.3 \text{Kbps} \)</span></li>
                <li>同样 10MB 的视频下载 1 分钟，平均下来网速即<span class="text-blue-math">\( \frac{10}{1 \times 60}=166.67 \text{KBps} \)</span>，<span class="text-blue-math">\( 166.67\times 8 \text{bit} = 1333.33 \text{Kbps} \)</span>
                    <ul class="text-gray-side">
                        <li>这里的 ÷1 代表缩放到一分钟范围，×60 代表缩放到一秒，×8bit 代表 1 Byte 转 8 bit。</li>
                    </ul>
                </li>
            </ul>

            <h3>色彩</h3>
            <p>人眼感光细胞捕获特定强度的电磁波（可见光），然后通过大脑处理，产生了我们所看到的幻觉。实际上，色彩只有一个标量属性，即频率。</p>
            <div class="align-items-center">
                <img src="files/basics/Color-Spectrum.png" alt="image2" class="img-medium" >
                <p class="text-gray-side mt-0">图：色彩的波形频率变化，见<a href="https://en.wikipedia.org/wiki/Electromagnetic_spectrum">维基百科</a>。</p>
            </div>

            <h3>亮度</h3>
            <ul>
                <li>物理亮度：可见光电磁波的强度或振幅，以流明 lumen/lm，坎德拉/烛光量 candela/cd，或尼特 nits/cdm<sup>2</sup> 计量：
                    <ul class="text-gray-side">
                        <li>1cd/lm 大约为一支普通蜡烛的亮度。</li>
                        <li>由于是强度，一般来说，灯泡电压越高、火药能量密度越高，发光就越明亮
                            <ul>
                                <li>因此定义：能量和光强的相关性呈正比</li>
                            </ul>
                        </li>
                        <li>Nits 代表 1cd 光源投射到一平方米（一般情况下距离一米）区域后所剩的亮度，主要用于显示器的亮度设定。一般来说，1 nit ≈ 3.426 lm，但实际的换算关系取决于光源和测量仪器的不同与误差。</li>
                    </ul>
                </li>
                <li>软硬件亮度：代表灰度像素值的大小，值越大表示像素点越亮，但最大亮度受硬件和用户设定限制。伽马 gamma/Y 值定义了像素的亮度范围，最小值 0 为黑色：
                    <ul class="text-gray-side">
                        <li>位深 4bit 下，最大值为 15（或 0xF），代表白色</li>
                        <li>位深 8bit 下，最大值为 255（或 0xFF），代表白色</li>
                        <li>位深 10bit 下，最大值为 1023（或 0x3FF），代表白色</li>
                    </ul>
                </li>
            </ul>
            <p>YUV / YCbCr 色彩空间图像的亮度平面 Y，或者 RGB 图像分离出的亮度/灰度平面，有时也被称为伽马平面或 Y 平面。</p>
            
            <h3>灰度/灰阶 Grayscale</h3>
            <p>代表将色彩信息去除，只保留黑、灰、白色的单通道图像。</p>
            
            <h3>色深 Depth</h3>
            <p>色深代表软硬件亮度从黑到白之间过渡的密度细分。由于计算机使用二进制表示，因此通常以如 4bit 表示 16 色深（<span class="text-blue-math">\( 2^4 \)</span>）、8bit 表示 256 色深（<span class="text-blue-math">\( 2^8 \)</span>）、10bit 表示 1024 色深（2^10）的形式呈现。早期模拟电视使用 <span class="text-blue-math">\( 0 \text{mV} ~ 700 \text{mV} \)</span> 的电压表示色深，但考虑到电视台调制，以及受一定干扰的信号可能超出最大电压（导致烧坏显像电子枪或老化屏幕荧光粉），因此在这个区间内限制了色深的范围。</p>
            <p>限制后的色深将被重新映射到缩减的信号范围内，导致色深的密度降低。数字电视的 Bt.601 标准考虑到了质量不一的 DVD 播放机传输模拟信号到模拟电视的情况，因此也定义了有限的色深范围。其中：</p>
            <ul class=" text-smaller overflow-auto">
                <li>完整（Full：8 位色深下，色彩范围从 0 到 255 的完整 256 色深区间，密度较高，适用于游戏，软件和网页的矢量图场景</li>
                <li>有限/模拟/电视（Limited/Analog/TV Limited）：8 位色深下，色彩范围缩减至 16 到 235 的有限区间，密度较低，通常用于模拟信号电视，但因为跨平台兼容性最高，所以仍是推荐用于处理多媒体的色深</li>
                <li>当 Limited/TV 范围的硬件连接到 Fullrange 硬件（使用 HDMI 连接显示器时），显示器总是会缺失最暗到最亮的色彩范围，呈现出灰蒙蒙的画面，需要额外设置才能纠正</li>
                <li>当 Fullrange 的硬件连接到 Limited 范围的硬件时（例如电视设置为 Full，但连接到设置为 Limited 的 PS4/Xbox 时），可能会出现画面过亮、过暗、饱和度过高的错误显示</li>
                <li>因此，若整个显示系统（操作系统，显示驱动，显示器）都支持完整色域，则应设置为完整；否则一律设置为有限</li>
                <li>录制视频素材时，为了兼容所有多媒体平台（如网页浏览器，视频网站），通常会将其设置为有限范围</li>
                <li>抖动滤镜可以创造色深增加的错觉，以改善色彩平滑度</li>
            </ul>
            <div class="align-items-center">
                <img src="files/basics/Full-and-Limited-Range.png" alt="image3" class="img-medium" >
                <p class="text-gray-side mt-0">图：完整色深 Fullrange 与有限/TV 色深 Limited，包括上述说明的更优版本见<a href="https://www.youtube.com/watch?v=8sAJWtgQ2t8">硬件茶谈</a>。</p>
            </div>

            <h3>伽马曲线/伽马映射</h3>
            <ul class="text-smaller overflow-auto">
                <li>生理伽马映射：人眼对于亮度的感知与物理亮度的线性变化所异
                    <ul class="text-gray-side">
                        <li>人眼敏感于低至中等亮度的变化，而对中高亮度的变化则相对不太敏感。因此，当内容的亮度变化呈直线关系时，人们会感觉到“发白”</li>
                        <li>许多游戏的初始设置中，“将滑块调节到能清晰看到左侧暗部图像”实际上就是在调节伽马曲线，而且是生理伽马曲线</li>
                        <li>相机 CMOS 捕获的线性亮度（RAW 直出格式）在人眼看来会显得过亮“发白”，需要进行“黑化”校正</li>
                    </ul>
                </li>
                <li>软硬件伽马映射：屏幕电压与线性亮度变化之间的关系并非线性
                    <ul class="text-gray-side">
                        <li>CRT 显示屏一般需要放大电压到 <span class="text-blue-math">\( v^{2.2} \)</span> 才能够直线地显示亮度变化</li>
                        <li>sRGB 标准则因为 CRT 显示器的特性相当于已经对图像进行了“黑化”处理，因此在录制过程中就会将图像进行“白化”处理：<span class="text-blue-math">\( \gamma^{\frac{1}{2.2}} \)</span></li>
                        <li>若编辑 RAW 直出图像的软件未打开 Adobe 软件默认关闭的“按伽马系数混合 RGB 颜色，伽马值为 1”的设定，图层透明通道之间的过渡会显得杂乱不堪。</li>
                    </ul>
                </li>
            </ul>

            <h3>伽马矫正</h3>
            <p>分为两种方式：向上提亮缩放“白化”和向下变暗缩放“黑化”。矫正的算式为：<span class="text-blue-math">\( s = cr^\gamma \)</span></p>
            <div class="align-items-center">
                <img src="files/basics/Gamma-Correction.png" alt="image4" class="img-medium" >
                <p class="text-gray-side mt-0">图：伽马矫正的指数算式，见<a href="https://www.desmos.com/calculator/shseuk9jcb?lang=zh-CN">desmos 互动例</a>。</p>
            </div>
            
            <h3>对比度 Contrast</h3>
            <p>通常情况下，表示对音量、冷热、远近等两种程度的差异大小缩放。在图像/显示器中，对比度则代表最亮和最暗的显示亮度差异。图片的对比度低会显得发灰，因为当前的亮度设置位于这个灰度水平上。</p>
            <p>人眼在黑暗中观看同样的视频时，有些场景会显得过亮，有些场景则会显得太暗。这种情况下，降低对比度即可解决该问题；而在阳光下观看同样的视频时，即使将手机电脑调到最大亮度，也无法清晰看到暗部场景。这种情况下，降低对比度并增加亮度即可解决该问题。</p>
            <p>售卖手机的厂商可以考虑让所有用手机看视频的人都需要换手机：只需在下拉状态栏的亮度滑块条 Brightness 上增加一个“暗度 Darkness”滑块：</p>
            <ul>
                <li>亮度与暗度的间距决定对比度</li>
                <li>通过软件限制亮度与暗度滑块的最近距离，防止误操作</li>
                <li>上述内容已经说明调整对比度能解决几乎所有过亮或过暗场景的问题</li>
                <li>如果没有技术和耐心，则可以退而求其次，在亮度条的下方增加对比度条</li>
            </ul>

            <h3>饱和度 Saturation</h3>
            <p>一般指液体在特定压力和温度下溶解了某种成分的程度，达到最高时会沉积而不再溶解。图像中则代表颜色接近 100% 纯色的程度或“彩度”，饱和度越高则图像越鲜艳，为零时得到灰阶图像；最大时得到纯色图像。对比度接近饱和度，但不是饱和度。</p>

            <h3>像素 Pixel / pix / pel / px</h3>
            <p>像素是组成图像的最小单位，决定了图像的物理大小和分辨率。一般情况下分为屏幕的硬件像素大小，和图片/视频的软件像素大小两种。当软件像素小于硬件像素时，显示 100% 大小的图片会变小，或者通过缩放滤镜将图片放大以适应屏幕。反之，如果硬件像素大小小于软件像素，则会使用缩放滤镜将图片缩小至合适的尺寸，或者图片会溢出屏幕。图像中的每个像素都有位置和颜色两份信息。</p>

            <h3>每英寸像素 Pixel Per Inch / PPI</h3>
            <p>指屏幕或印刷设备上的物理像素密度，这取决于设计时预期的观看距离。屏幕的 PPI 高则适合近距离观看，因为物理像素更密集。在印刷设备的 PPI 越高，打印出的图像就越细腻。软件的 PPI 主要用于计算新建图像的像素大小和分辨率，以确保图像有着适当的大小和清晰度。</p>
            <p>矢量图形通常不涉及 PPI 概念，因为它们以数学方式描述图像，可以无限放大而不失真。</p>
            <p>高 PPI 的显示器是一种较新的规格，旧的软件在这些显示器上会出现模糊，或界面过小的问题，见<a href="https://www.youtube.com/watch?v=jfAH4Ym5D6Q">硬件茶谈</a>。</p>

            <h3>位图 Bitmap 与矢量图 Vector</h3>
            <p>位图使用像素和元数据（例如 n 个像素后换行）来表示图像。每个像素都包含特定的颜色信息，通常表示为 RGB 或 YCbCr 值。用于描述照片和复杂图像，但当放大时会失真，因为像素的信息已经固定，而放大只是用滤镜在其中插值填空的结果。</p>
            <p>矢量图使用图形函数代码（例如 JavaFX，SVG）来描述图像。它们以函数定义图像的形状、线条和颜色。矢量图可以被放大而不失真，并且可以在不同的尺寸和分辨率下保持清晰度，因为它们是基于数学公式的。</p>
            <p>尽管矢量图优点明显，但它们相对较少见，因为需要编写复杂的渲染器来处理它们，而且难以确保在不同平台上的一致性。然而，如果我们将“文本”视为一种矢量图形式的话，位图在实际应用中反而才是更为少见的。</p>

            <h3>色彩空间 Color Space</h3>
            <div class="row">
                <p id="LR-UD-001" class="col-10">用于表示和处理图像颜色的数据格式，具有适用于各种不同应用场景的多种类型。最常用的是分为硬件和操作系统的 RGB 色彩空间，以及内容的 YUV/YCbCr 色彩空间。见 <a href="https://www.youtube.com/watch?v=FTKP0Y9MVus">Captain Disillusion</a> 的科普。</p>
                <img src="files/basics/RGB-to-YCbCr-to-RGB.png" alt="image5" id="LR-UD-002" class="img-small img-right col-2 mb-auto" >
            </div>
            <p>RGB 色彩空间由红色 Red、绿色 Green、蓝色 Blue 三个通道组成，每个通道的数值表示相应颜色的强度，对应着显示器红色 LED，绿色 LED 和蓝色 LED。常用于显示器、摄像头和图形处理等硬件和软件系统中。</p>
            <p>YUV/YCbCr 色彩空间是另一种常见的色彩表示方式，用于存储和传输视频数据。Y 代表亮度 Luminance，而 U、V 代表色度 Chrominance。YCbCr 特指数字信号，YUV 特指模拟信号，再无区别。由于后者字数更少且不需要频繁切换大小写，打字更容易，所以 YUV 拼写后来逐渐被当做讨论用的“平替”。</p>
            <table class="table-center">
                <thead>
                    <tr>
                        <th>🎆色彩格式</th>
                        <th>构成色</th>
                        <th>特点</th>
                        <th>存在原因</th>
                        <th>支持范围</th>
                    </tr>
                </thead>
                <tbody>
                    <tr class="border-bottom">
                        <td class="px-1"><span style="color:red">R</span><span style="color:lime">G</span><span style="color:blue">B</span></td>
                        <td class="px-1">红绿蓝</td>
                        <td class="px-1">通用</td>
                        <td class="px-1">使显示器/照相机通用</td>
                        <td class="px-1">几乎所有可视媒体</td>
                    </tr>
                    <tr class="border-bottom">
                        <td class="px-1"><span style="color:#BFBFBF">A</span><span style="color:red">R</span><span
                                style="color:lime">G</span><span style="color:blue">B</span></td>
                        <td class="px-1">α 红绿蓝</td>
                        <td class="px-1">透明通道</td>
                        <td class="px-1">便于图层化编辑</td>
                        <td class="px-1">图片，部分视频</td>
                    </tr>
                    <tr class="border-bottom">
                        <td class="px-1"><span style="color:aqua">C</span><span style="color:fuchsia">M</span><span
                                style="color:yellow">Y</span><span style="color:black">K</span></td>
                        <td class="px-1">湛 zhàn 洋黄黑</td>
                        <td class="px-1">减法色彩</td>
                        <td class="px-1">卖墨盒</td>
                        <td class="px-1">打印纸</td>
                    </tr>
                    <tr>
                        <td class="tx-1"><span class="text-fade-y">Y</span><span class="text-fade-cb">Cb</span><span class="text-fade-cr">Cr</span> (YUV，似 YPbPr)</td>
                        <td class="px-1">白蓝 - 黄红 - 绿</td>
                        <td class="px-1">压缩</td>
                        <td class="px-1">压缩视频图片</td>
                        <td class="px-1">所有有损压缩</td>
                    </tr>
                </tbody>
            </table>

            <h3>色度采样 Chroma Subsampling</h3>
            <p>YUV/YCbCr 色彩空间下，利用人眼对色度细节不敏感的特性（见下图全分辨率和半分辨率的色度面），降低色度平面的分辨率，从而压缩图像。色度采样格式通常用三个数字表示，例如 4:4:4、4:2:2 等。</p>
            <p>A:B:C 代表微观分辨率下，每个长 A 像素，高 2 像素的空间，第一行缩到 B 个色度像素，第二行缩到 C 个色度像素。如 4:2:2 代表色度平面的每个 4x2 微观区间中，第一行的色度分量保留 2 个像素，第二行的色度分量也保留 2 个像素。色度采样详见下表：</p>
            <div class="overflow-auto">
                <table class="table-center align-items-center text-smaller" style="white-space: nowrap;">
                    <thead class="thead-no-border">
                        <tr class="t-invert-dark">
                            <th class="px-0">👾采样</th>
                            <th class="px-0">1920x1080 下宏观</th>
                            <th class="px-0" colspan="4">色度 4x2 微观</th>
                            <th class="px-1">特点</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr class="border-bottom">
                            <td class="px-1 t-light-gray" rowspan="2">4:4:4</td>
                            <td class="px-1" rowspan="2">亮度，色度皆 1920x1080</td>
                            <td class="px-0 t-light-gray square" style="white-space: nowrap;">色素</td>
                            <td class="px-0 t-invert-light square" style="white-space: nowrap;">色素</td>
                            <td class="px-0 t-light-gray square" style="white-space: nowrap;">色素</td>
                            <td class="px-0 t-invert-light square" style="white-space: nowrap;">色素</td>
                            <td rowspan="2">逐行，读写亮色度而不用从 RGB 转——剪视频快</td>
                        </tr>
                        <tr class="border-bottom">
                            <td class="px-0 t-invert-dark" style="white-space: nowrap;">色素</td>
                            <td class="px-0 text-lightgray" style="white-space: nowrap;">色素</td>
                            <td class="px-0 t-invert-dark" style="white-space: nowrap;">色素</td>
                            <td class="px-0 text-lightgray" style="white-space: nowrap;">色素</td>
                        </tr>
                        <tr class="border-bottom">
                            <td class="px-1 t-light-gray" rowspan="2">4:2:2</td>
                            <td class="px-1" rowspan="2">亮度不变，色度 960x1080</td>
                            <td class="px-0 t-light-gray twoByOne" colspan="2">色素 ←</td>
                            <td class="px-0 t-invert-light twoByOne" colspan="2">色素 ←</td>
                            <td class="px-1 t-light-gray" rowspan="4">逐行扫描，颜色像素靠插值还原。直接读写亮度所以剪视频比 RGB 快</td>
                        </tr>
                        <tr class="border-bottom">
                            <td class="px-0 t-invert-dark twoByOne" colspan="2" style="white-space: nowrap;">色素 ←</td>
                            <td class="px-0 text-lightgray twoByOne" colspan="2" style="white-space: nowrap;">色素 ←</td>
                        </tr>
                        <tr class="border-bottom">
                            <td class="px-1 t-light-gray">4:2:0</td>
                            <td class="px-1">亮度不变，色度半宽半高 960x540</td>
                            <td class="px-0 t-light-gray square" colspan="2">色素 ←<br>↑&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;⬉</td>
                            <td class="px-0 t-invert-light square" colspan="2">色素 ←<br>↑&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;⬉</td>
                        </tr>
                        <tr class="border-bottom">
                            <td class="px-1 t-light-gray">4:4:0</td>
                            <td class="px-1">亮度不变，色度全宽半高 1920x540</td>
                            <td class="px-0 t-light-gray OneByTwo" style="white-space: nowrap;">色素<br>↑</td>
                            <td class="px-0 t-invert-light OneByTwo" style="white-space: nowrap;">色素<br>↑</td>
                            <td class="px-0 t-invert-dark OneByTwo" style="white-space: nowrap;">色素<br>↑</td>
                            <td class="px-0 text-lightgray OneByTwo" style="white-space: nowrap;">色素<br>↑</td>
                        </tr>
                        <tr class="border-bottom">
                            <td class="px-1 t-light-gray" rowspan="2">4:1:1</td>
                            <td class="px-1" rowspan="2">亮度不变，色度 1/4 宽全高 480x1080</td>
                            <td class="px-0 t-light-gray fourByOne" colspan="4" style="white-space: nowrap;">色素 ← ← ← ←</td>
                            <td class="px-1" rowspan="4">交错扫描 Interlaced，横着扫就不会把另一场的帧参考而浪费算力了</td>
                        </tr>
                        <tr class="border-bottom">
                            <td class="px-0 t-invert-dark fourByOne" colspan="4" style="white-space: nowrap;">色素 ← ← ← ←</td>
                        </tr>
                        <tr class="border-bottom">
                            <td class="px-1 t-invert-light" rowspan="2">4:1:1-par4:3</td>
                            <td class="px-1" rowspan="2">亮度 3/4 宽全高，1440x1080 色度 3/16 宽全高，360x1080</td>
                            <td class="px-0 t-light-gray fourByOne" colspan="4" style="white-space: nowrap;">色度像素 5.333×←</td>
                        </tr>
                        <tr class="border-bottom">
                            <td class="px-0 t-invert-dark fourByOne" colspan="4" style="white-space: nowrap;">色度像素 5.333×←</td>
                        </tr>
                        <tr>
                            <td class="px-1 t-invert-light">4:2:0-par4:3</td>
                            <td class="px-1">亮度 3/4 宽全高，1440x1080 色度 3/8 宽半高，720x540</td>
                            <td class="px-0 t-light-gray square" colspan="2" style="white-space: nowrap;">2.667 ←<br>↑ 2.848 ⬉</td>
                            <td class="px-0 t-invert-light square" colspan="2" style="white-space: nowrap;">2.667 ←<br>↑ 2.848 ⬉</td>
                            <td class="px-1 t-light-gray">逐行扫描，非方形亮度像素，par 通常是 4:3 <del class="text-lightgray">要不然太烧脑了</del></td>
                        </tr>
                    </tbody>
                </table>
            </div>

            <div class="align-items-center mt-3">
                <img src="files/basics/Color-Space-Handling.jpg" alt="image6" class="image-medium">
                <p class="text-gray-side mt-0">图：RGB 与 YCbCr 的转换，色度采样的使用及编解码与录制，传输，显示的关系</p>
            </div>

            <h3>压缩的策略</h3>
            <p>根据硬件的算力和带宽两种限制选择有损压缩，无损压缩和未压缩。一种（图/视/音频）编码可集成全部三种策略。</p>
            <ul class="text-smaller">
                <li>算力 Computing Power：处理器或硬件解码器的速度和效率，低于解码难度（编码复杂度）则不能流畅播放。</li>
                <li>带宽 Bandwidth：网速，硬盘读写和内存传输带宽，低于带宽压力（Mbps）则不能流畅播放。</li>
                <li>DVD 播放机，蓝光播放机为确保流畅，也会和网络传输一样限制带宽。</li>
            </ul>
            <table class="table-center">
                <thead>
                    <tr>
                        <th> </th>
                        <th>编码强度设定</th>
                        <th>带宽负载</th>
                        <th>解码负载</th>
                    </tr>
                </thead>
                <tbody>
                    <tr class="border-bottom">
                        <td class="px-1">未压缩</td>
                        <td class="px-1">无</td>
                        <td class="px-1">最高</td>
                        <td class="px-1">最低</td>
                    </tr>
                    <tr class="border-bottom">
                        <td class="px-1">无损压缩</td>
                        <td class="px-1">低</td>
                        <td class="px-1">高</td>
                        <td class="px-1">低</td>
                    </tr>
                    <tr class="border-bottom">
                        <td class="px-1">无损压缩</td>
                        <td class="px-1">高</td>
                        <td class="px-1">中~高</td>
                        <td class="px-1">中~低</td>
                    </tr>
                    <tr class="border-bottom">
                        <td class="px-1">有损压缩</td>
                        <td class="px-1">低</td>
                        <td class="px-1">高</td>
                        <td class="px-1">低</td>
                    </tr>
                    <tr>
                        <td class="px-1">有损压缩</td>
                        <td class="px-1">高</td>
                        <td class="px-1">低</td>
                        <td class="px-1">高</td>
                    </tr>
                </tbody>
            </table>
            <p>只要录制，剪辑，调色，混音，导出中一个环节用错了录制设备，采样率/色深，色彩空间，分辨率，像素宽高比，颜色混合，伽马映射等设定，损失就已成定局，此时选择有损或无损编码就不再有意义。</p>

            <h3>视频压制</h3>
            <p>视频压制是视频编码器用户追求画质、压缩率和速度的逻辑。单纯地追求速度并不能发挥编码器的最大压缩能力。很多人一开始只看到硬件编码器速度快，就忽视了软件编码器的高压缩率。</p>

            <h3>视频压制三角定律</h3>
            <p>确定压缩策略和设备购买的方法。专用编码器通常用于单一目的，但难以控制损失；通用编码器用途广泛，但损失易于控制。高算力适合通用策略，而低算力则适合专用策略。</p>
            <div class="align-items-center">
                <img src="files/basics/Encoding-Trade-off-Triangle.png" alt="image7" class="img-medium">
                <p class="text-gray-side mt-0">图：三种关键出发点构成的三角形。其“完美中心点”的存在和必要性取决于软硬件和用户</p>
            </div>

            <h3>音频格式（一维）</h3>
            <p>最简单的结构为：脉冲编码调制<a href="https://zh.wikipedia.org/wiki/%E8%84%88%E8%A1%9D%E7%B7%A8%E7%A2%BC%E8%AA%BF%E8%AE%8A">Pulse-code modulation PCM</a>信号</p>
            <table class="table-center align-items-center text-smaller">
                <thead class="thead-no-border">
                    <tr class="t-invert-dark">
                        <th class="px-1">🎶压缩</th>
                        <th class="px-1">格式</th>
                        <th class="px-1">音质</th>
                    </tr>
                </thead>
                <tbody>
                    <tr class="border-bottom">
                        <td class="px-1 t-light-gray">有损</td>
                        <td class="px-1">mp3，aac，ogg（vorbis/opus）</td>
                        <td class="px-1 t-light-gray" rowspan="3">取决于耳机/音响，混音，声场。分为 HiFi 音频和监听音频两种质量参考</td>
                    </tr>
                    <tr class="border-bottom">
                        <td class="px-1 t-invert-light">无损</td>
                        <td class="px-1">flac，alac，ape，it</td>
                    </tr>
                    <tr>
                        <td class="px-1 t-invert-dark">未压缩</td>
                        <td class="px-1">wav（PCM）</td>
                    </tr>
                </tbody>
            </table>
            
            <h3>图像格式（二维）</h3>
            <p>最简单的结构为 PCM 信号 + 每 n 个像素换行的元数据</p>
            <div class="overflow-auto">
                <table class="table-center align-items-center text-smaller">
                    <thead class="thead-no-border">
                        <tr class="t-invert-dark">
                            <th>📷压缩</th>
                            <th>格式</th>
                            <th>最大 RGB 色深</th>
                            <th>最大 YUV 色深</th>
                            <th>最大 CMYK 色深</th>
                            <th>动图</th>
                            <th>HDR</th>
                            <th>透明</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr class="border-bottom">
                            <td class="px-1 t-light-gray">有损</td>
                            <td class="px-1">jpg</td>
                            <td class="px-1 t-light-gray">8 <span class="text-lightgray">8 8</span></td>
                            <td class="px-1">8 <span class="text-lightgray">8 8</span></td>
                            <td class="px-1 t-light-gray">24 <span class="text-lightgray">24 24 24</span></td>
                            <td class="px-1"> </td>
                            <td class="px-1"> </td>
                            <td class="px-1"> </td>
                        </tr>
                        <tr class="border-bottom">
                            <td class="px-1 t-light-gray" rowspan="4">有~无损</td>
                            <td class="px-1">gif（编码无损，颜色少了）</td>
                            <td class="px-1 t-light-gray">24×3 中取 8×3</td>
                            <td class="px-1"> </td>
                            <td class="px-1 t-light-gray"> </td>
                            <td class="px-1">√</td>
                            <td class="px-1"> </td>
                            <td class="px-1">仅 1bit</td>
                        </tr>
                        <tr class="border-bottom">
                            <td class="px-1">webp</td>
                            <td class="px-1 t-light-gray">8 <span class="text-lightgray">8 8</span></td>
                            <td class="px-1">8 <span class="text-lightgray">8 8</span></td>
                            <td class="px-1 t-light-gray"> </td>
                            <td class="px-1">√</td>
                            <td class="px-1"> </td>
                            <td class="px-1">√</td>
                        </tr>
                        <tr class="border-bottom">
                            <td class="px-1">jpg-XR（兼容 jpg）</td>
                            <td class="px-1 t-light-gray">32 <span class="text-lightgray">32 32</span></td>
                            <td class="px-1">8 <span class="text-lightgray">8 8</span></td>
                            <td class="px-1 t-light-gray">16 <span class="text-lightgray">16 16 16</span></td>
                            <td class="px-1">√</td>
                            <td class="px-1">√</td>
                            <td class="px-1">√</td>
                        </tr>
                        <tr class="border-bottom">
                            <td class="px-1">avif，heif/heic，filf</td>
                            <td class="px-1 t-light-gray">32 <span class="text-lightgray">32 32</span></td>
                            <td class="px-1">16 <span class="text-lightgray">16 16</span></td>
                            <td class="px-1 t-light-gray"> </td>
                            <td class="px-1">√</td>
                            <td class="px-1">√</td>
                            <td class="px-1">√</td>
                        </tr>
                        <tr class="border-bottom">
                            <td class="px-1 t-invert-light">无损</td>
                            <td class="px-1">pdf，jpg-LS，png</td>
                            <td class="px-1 t-light-gray">16 <span class="text-lightgray">16 16</span></td>
                            <td class="px-1"> </td>
                            <td class="px-1 t-light-gray">32 <span class="text-lightgray">32 32 32</span></td>
                            <td class="px-1">仅 mng</td>
                            <td class="px-1"> </td>
                            <td class="px-1">√</td>
                        </tr>
                        <tr class="border-bottom">
                            <td class="px-1 t-invert-light">有损~无损~未压</td>
                            <td class="px-1">tif</td>
                            <td class="px-1 t-light-gray">16 <span class="text-lightgray">16 16</span></td>
                            <td class="px-1">8 <span class="text-lightgray">8 8</span></td>
                            <td class="px-1 t-light-gray">128 <span class="text-lightgray">128 128 128</span></td>
                            <td class="px-1"> </td>
                            <td class="px-1">√</td>
                            <td class="px-1">√</td>
                        </tr>
                        <tr class="border-bottom">
                            <td class="px-1 t-invert-dark" rowspan="2">未压缩</td>
                            <td class="px-1">raw，bmp</td>
                            <td class="px-1 t-light-gray">24 <span class="text-lightgray">24 24</span></td>
                            <td class="px-1"> </td>
                            <td class="px-1 t-light-gray"> </td>
                            <td class="px-1">仅 raw</td>
                            <td class="px-1">√</td>
                            <td class="px-1">√</td>
                        </tr>
                        <tr>
                            <td class="px-1">dpx</td>
                            <td class="px-1 t-light-gray">64 <span class="text-lightgray">64 64</span></td>
                            <td class="px-1">16 <span class="text-lightgray">16 16</span></td>
                            <td class="px-1 t-light-gray"> </td>
                            <td class="px-1">√</td>
                            <td class="px-1">√</td>
                            <td class="px-1"> </td>
                        </tr>
                    </tbody>
                </table>
            </div>

            <h3>视频格式（三维）</h3>
            <p>最简单的结构为一组图片。</p>
            <div class="overflow-auto">
                <table class="table-center align-items-center text-smaller">
                    <thead class="thead-no-border">
                        <tr class="t-invert-dark">
                            <th>🎥压缩</th>
                            <th>格式</th>
                            <th>RGB/YUV 色深</th>
                            <th>HDR</th>
                            <th>透明</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr class="border-bottom">
                            <td class="px-1 t-light-gray">有~无损</td>
                            <td class="px-1">qt，<a href="https://x265.readthedocs.io/">hevc</a>，avc，vvc，vp8/9，DNxHR/HD，prores</td>
                            <td class="px-1 t-light-gray">12 <span class="text-lightgray">12 12</span></td>
                            <td class="px-1">除 avc，vp8</td>
                            <td class="px-1">仅 prores</td>
                        </tr>
                        <tr class="border-bottom">
                            <td class="px-1 t-invert-light" rowspan="2">无损</td>
                            <td class="px-1">rawvideo</td>
                            <td class="px-1 t-light-gray">32 <span class="text-lightgray">32 32</span></td>
                            <td class="px-1"> </td>
                            <td class="px-1"><a href="https://www.tablesgenerator.com/html_tables#_%E7%94%9F%E6%88%90%E9%80%8F%E6%98%8Erawvideo">√</a></td>
                        </tr>
                        <tr class="border-bottom">
                            <td class="px-1"><a href="https://github.com/marksfink/cfenc">cineform</a></td>
                            <td class="px-1 t-light-gray">16 <span class="text-lightgray">16 16</span></td>
                            <td class="px-1">√</td>
                            <td class="px-1"> </td>
                        </tr>
                        <tr>
                            <td class="px-1 t-invert-dark">有损~无损~未压</td>
                            <td class="px-1">Flash 动画</td>
                            <td class="px-1 t-light-gray" colspan="3">内嵌图片决定</td>
                        </tr>
                    </tbody>
                </table>
            </div>
            <p>图片与视频之间还有图像序列，动图两种中间格式。图像序列直接储存视频为大量图像，一般用于录制素材；动图如 .gif，.mng 则几乎和视频流一致，就是未封装而储存了帧率的数据流。</p>

            <h3>滤镜/滤波器 Filter 与滤镜工具</h3>
            <p>通常用于过滤水和净化空气。在信号中代表处理一维音频和二维视频信号的算法。滤镜工具代表能够将滤镜应用到信号上的软件或插件，比如 Adobe Premiere Pro，After Effects，<a href="https://ffmpeg.org/">ffmpeg</a>，<a href="https://www.blackmagicdesign.com">DaVinci Resolve</a>，<a href="https://www.screentogif.com/">ScreenToGIF</a>，<a href="https://www.image-line.com">FL Studio</a>，<a href="https://www.reaper.fm/">Reaper</a>，<a href="https://www.ableton.com/">Ableton</a>，Audition，<a href="https://www.gimp.org/">GIMP</a>，Photoshop，<a href="https://www.faststone.org/FSCaptureDetail.htm">FSCapture</a>，LightRoom，OpenCV 等编辑图像、视频和音频的工具。<a href="https://avs-plus.net/">AviSynth(+)</a>和 VapourSynth 严格上称为帧服务器，因为需要连接一个编码器才能导出视音频。</p>

            <h3>好看与难看的噪声 Noise</h3>
            <p>电影胶片（卤化银晶体）被投影灯放大得到胶片颗粒 Film Grain，在单独一帧胶片画面上是一种静态噪声。更广义的噪声是模拟电视使用放大电路 amplifier 放大无信号频段所产生的“雪花”画面（和声音）、视频/图像暗部画面的动/静态噪声、显示器屏幕磨砂表面的静态噪声（不同厂家镀膜工艺水平不同）等等。因此，就有了好看与难看的噪声。</p>
            <div class="align-items-center">
                <img src="files/basics/imax-tape-projector.jpg" alt="image8" class="img-medium">
                <p class="text-gray-side">图：正在放映 2023 年电影《奥本海默》的 70mm IMax 胶片放映机。源：<a href="https://www.cnbc.com/2023/07/19/where-to-watch-oppenheimer-in-70mm-imax-.html">Nicolas Vega</a></p>
                <img src="files/basics/matte-vs-glossy.jpg" alt="image9" class="img-medium">
                <p class="text-gray-side">图：磨砂镀膜与镜面镀膜显示器的微观区别。可以看到没有漫反射的镜面更加“通透”。源：<a href="https://www.youtube.com/watch?v=mZjxEcuVHlQ">The Display Guy</a></p>
            </div>

            <h3>抖动滤镜 Dither Filter</h3>
            <p>源自早期操作系统只能显示有限数量的颜色，因此采用了高频闪烁两种颜色的方法来欺骗视觉（副作用是使人感到晕眩）。在图像、音频和低端显示器中，抖动滤镜代表通过分辨率或采样率来换取位深的加噪补偿手段。</p>
            <button type="button" class="collapsible border-main rounded-3">点击展开/折叠内容：常用的抖动滤镜，可略</button>
            <div class="coll-content">
                <p>具体来说，通过间隔几个像素就调亮/调暗一个像素的颜色，使得宏观整体上看起来像是淡化或加深；在音频位深分量两端的采样点间成比例的（以方形波或三角波信号）快速摆动，从而利用扬声器反应速度，起到淡化或深化偏移宏观上位深的效果。</p>
                <div class="align-items-center">
                    <img src="files/basics/Audio-Dither.png" alt="image10" class="img-medium">
                    <p class="text-gray-side mt-0">图：音频的采样点，以及下采样音频，抖动关对比开的效果，见<a href="https://micoope.com.gt/?s=what-is-audio-dithering-and-why-it-s-used-aa-BaD6b0T5">Micoope 科普</a>。</p>
                    <img src="files/basics/Image-Dither-1.png" alt="image11" class="">
                    <p class="text-gray-side mt-0">图：下采样 8bit 到 1bit，开抖动的效果</p>
                </div>
                <p>抖动滤镜的效果主要是欺骗视觉，但因为效果独特，所以衍生出了 Ditherpunk 抖动朋克美术。典型如 1bit 游戏《奥博拉丁的回归》贯彻了这种风格——利用<a href="https://bartwronski.com/2016/10/30/dithering-part-one-simple-quantization/">随机</a>，<a href="https://bartwronski.com/2016/10/30/dithering-part-two-golden-ratio-sequence-blue-noise-and-highpass-and-remap/">蓝噪声</a>，<a href="https://bartwronski.com/2016/10/30/dithering-part-two-golden-ratio-sequence-blue-noise-and-highpass-and-remap/">蓝噪声，黄金分割</a>，<a href="https://www.compuphase.com/riemer.htm">Riemersma</a> 等不同的加噪算法来定义游戏引擎的材质。</p>
                <div class="align-items-center">
                    <img src="files/basics/Image-Dither-2.png" alt="image12" class="img-medium">
                    <p class="text-gray-side mt-0">图：图像噪声算法</p>
                </div>
            </div>

            <h3>缩放滤镜 Resize Filter</h3>
            <p>Windows 系统一般用双线性缩放放大 PPI 小的软件，视频视频播放器一般用 bicubic 或 lanczos 插值</p>
            <button type="button" class="collapsible border-main rounded-3">点击展开/折叠内容：更改图像大小的各种算法，可略</button>
            <div class="coll-content">
                <h5>临近取样插值 Nearest Neighbour interpolation（NN）：</h5>
                <ol class="text-smaller">
                    <li>2x2 的四个像素点移动到缩放后的四个位置</li>
                    <li>待插值的像素中，距离哪四个点近的像素就取哪个像素的值</li>
                </ol>
                <h5>双线性插值 Bi-linear interpolation（Bi-lerp / Bilinear）：</h5>
                <ol class="text-smaller">
                    <li>2x2 的四个像素点移动到缩放后的四个位置</li>
                    <li>横向和纵向的点（像素值）间各连一条线</li>
                    <li>采样得到中间的像素，完成四边的插值</li>
                    <li>四边之间接着分为横向与纵向边缘</li>
                    <li>横向和纵向的边（像素值）间各连一条线，共六横六纵</li>
                    <li>所有线段接着采样得到中间的插值像素点，且在横纵线的两种插值之间取平均</li>
                </ol>
                <h5>样条插值 Spline interpolation（spline）：</h5>
                <ol class="text-smaller">
                    <li>“样条”代表软木条，通过铁钉塑形结合木条的应力做出连贯且一致的曲线</li>
                    <li>这种性质可以用多项式准确描述，而图像中的“铁钉”就是像素值</li>
                    <li>图像中的“木条”就是在 n 个“铁钉”构成的 n-1 个区间里各画一条曲线</li>
                    <li>二次多项式插值 quadratic interpolation 代表三个点间用二次多项式插值</li>
                    <li>三次多项式插值 cubic interpolation 代表四个点间用三次多项式插值，适用于放大图像</li>
                    <li>连起的线必须平滑连贯，数学上叫做“二阶导数连续”
                        <ul>
                            <li>因此，放大一个 2x2 的区间需要 4x4 范围的采样点</li>
                        </ul>
                    </li>
                    <li>插值的与逻辑和双线性插值一致，同时是三次多项式插值，则是双三次多项式插值 bi-cubic interpolation</li>
                </ol>
                <h5>Lanczos 插值：</h5>
                <p class="text-smaller">使用 sinc 函数取近似，且引入了窗函数来矫正 sinc 函数，同时要计算 lanczos 核实现插值。计算量大，准确度略高于 bicubic 插值。</p>
                <h5>神经网络缩放滤镜：</h5>
                <p class="text-smaller">通过认知大量训练数据，在其中找出更高维度规律的情况下，利用这些规律推断像素值。计算量极大，准确度时高时低。</p>
            </div>

            <h3>宽高比/展弦比 Aspect Ratio</h3>
            <p>固定翼飞机或者矩形的最小两边分量。被忽略的“长”是因为飞机相对地面，屏幕相对人眼的 z 轴。而换算长短边如 16:9 高 720 的方形像素视频，其宽就是 <span class="text-blue-math">\( 720 \div 9 \times 16 = 1280 \)</span>。</p>
            <div class="align-items-center">
                <img src="files/basics/Aspect-Ratio-16-by-9.png" alt="image13" class="img-medium">
                <p class="text-gray-side mt-0">图：16:9 的矩形整数偶数放大后的图像分辨率</p>
            </div>
            <p>图片格式一般支持奇数分辨率，视频一般仅支持偶数分辨率。</p>

            <h3>高/低频 High/Low frequency</h3>
            <p>假设函数 <span class="text-blue-math">\(y=\cos\left(ux\right)\)</span>。可以调节变量 u，如 <span class="text-blue-math">\(y=\cos\left(2x\right)\)</span>，<span class="text-blue-math">\(y=\cos\left(3x\right)\)</span>  等。u 越大则余弦函数周期越短——频率越高；u 越小则余弦函数周期越长——频率越低。</p>
            <p>变换算法可以将这个 u 作为输出数轴，原始波形中从低频到高频的分量都会被准确地排列进来。</p>

            <h3>程序的交互界面 Interface</h3>
            <p>图形界面交互 Graphic user interface GUI：通过图形元素（如按钮、滑块、菜单等）进行用户交互的界面设计。随着程序复杂度的增加，设计出好用的界面会变得更加困难。因此，只有在利润丰厚、注重美学设计、且拥有设计人才的行业才会推出外观精美的 GUI。然而，外观好看并不一定意味着好用、再而，很多时候有外观用都是一种奢求。
            </p>
            <div class="align-items-center">
                <img src="files/basics/FL-Studio-GUI-Demonstration.png" alt="image14" class="img-medium">
                <p class="text-gray-side mt-0">图：音频插件宿主软件 FL Studio，外加一堆免费和“免费”音频插件随便摆放的外观</p>
                <img src="files/basics/XMAPP-GUI-Demonstration.png" alt="image15" class="img-medium">
                <p class="text-gray-side mt-0">图：网页服务器宿主软件 XMAPP 的 GUI（左下为 CLI），作为跨行业对比</p>
            </div>
            <p>命令行交互 Commandline interface CLI：在如 Terminal、Bash、CMD 和 PowerShell 的终端环境中，用户可以手动输入命令并按回车键查看结果。通常，只要输出结果有一定的文本排版，就可以轻松阅读。随着使用的增加，CLI 可能反而会变得比 GUI 更方便。然而，由于某些命令太长，而且需要储存变量，因此为了简化操作，人们会将其写作批处理、Shell 等命令脚本文件。例如<a href="https://nazorip.site/archives/835/">PowerShell 一站式系统硬件检测</a>的脚本。</p>
            <p>应用编程交互 Application programming interface API：定义了软件应用程序如何相互通信的规则和工具。用于使开发人员和从程序的外部访问，以便在自己的应用程序中集成其中的功能。API 可以被看作是 CLI 的映射源，当开发者没有编写 CLI 参数或 GUI 时，可以退而求 API 来调用所需的功能。尽管 API 通常不直接面向最终用户，但它们在软件开发中非常重要</p>

            <h3>帧率 Frame Rate / Frames per second FPS</h3>
            <p>帧 Frame 通常用来描述连续图片序列中的单张图片。帧率 Frame Rate 是指每秒显示/刷新的图像帧数。帧率越高，则连续背景变化越流畅。因此，在游戏中，例如微软模拟飞行、极限着陆等模拟客机的游戏，以及电影运镜等故意限制背景变化程度的场景，其帧率一般只需要 30fps 左右（每秒更新 30 张画面）。而对于背景高速运动的游戏，比如模拟赛车等，即使是在手机平台上，最低帧率也不能低于 120fps。</p>
            <p>在动漫中，如果背景高速移动变化时的帧率低于 60fps，观看体验会大大降低，例如《进击的巨人》中的部分场景。相反，对于一些其他动漫，如果设计师本意是为了降低成本而利用视觉暂留原理来创建顿挫画面，那么低帧率反而会破坏观赏体验。</p>

            <h3>逐行 Progressive 与交错 Interlaced 扫描</h3>
            <p>逐行扫描通过一行行从左到右地刷新像素来构建图像，是最为常用的屏幕刷新方式。交错扫描的方法不同，它使用 YUV 4:1:1 采样，将屏幕的奇数像素行视为一个场，偶数像素行视为另一个场。这两个场在录制时错开一定时间，这样在模拟电视上观看时会产生 60fps 的视觉效果。交错扫描的原理是为了节省模拟电视信号的频段区间（与收音机接收电台信号一样）。因此，通过在时间上分隔行来节省空间，可以几乎将每个频道的频宽减半，例如（<span class="text-blue-math">\(525 \text{行} \times 30\text{fps} = 15.75 \text{MHz}\)</span>）。</p>
            <div class="align-items-center">
                <img src="files/basics/PAL-NTSC-SECAM.svg" alt="image16" class="img-medium">
                <p class="text-gray-side mt-0">图：NTSC，PAL 和 SECAM 播放规格的地区分布，见<a href="https://en.m.wikipedia.org/wiki/File:PAL-NTSC-SECAM.svg">维基百科</a></p>
            </div>

            <h3>小数帧率 / 丢帧</h3>
            <p>NTSC 模拟电视每个频道的标准带宽大约为 6MHz（但实际宽度仅为 4.5MHz）。接下来发生的事谁都没有预料到——彩色电视出现了。结果是原本的频宽完全放不下彩色电视台信号，而且由于电视机已经售出，不可能更改用户家里电视的频宽和扫描线的数量。最终解决方案是在每秒 30 帧的基础上丢掉一帧，并加速 1 秒到 1.1001 秒，以保持与帧率的对齐（同时也引入了 YUV 4:2:0 色彩空间）。经过这般折腾，码率/频宽总算被压缩了下来，但后继影响了数字视频的丢帧帧率标准——为了与模拟电视兼容<a href="https://www.reddit.com/r/finalcutpro/comments/mm58qp/why_on_earth_do_we_have_2997fps_what_madness_is/">Reddit: GhostOfSorabji
            </a>。</p>
            <p>在视频编辑中，对齐帧率不同视频是极其困难的操作，而这个天大的难题只需更改录制设定（点击两三个按钮）即可解决。</p>
            <div class="align-items-center">
                <img src="files/basics/Aligning-framerates.jpg" alt="image17" class="img-small">
                <p class="text-gray-side mt-0">图：不同帧率的对齐地狱，见<a href="https://www.youtube.com/watch?v=p3Jb3UPAw-w">Taran Van Hemert</a></p>
            </div>

            <h3>恒定 Constant 与可变 Variable 帧率</h3>
            <p>恒定帧率的视频播放和剪辑都最具兼容性。可变帧率有助于解决手机录像时的发热和耗电速度快的问题，同时，将可变帧率转换为恒定帧率以正常剪辑视频时则需要重新编码。因此，录制视频时应根据设备的电量和散热能力进行选择，而录制需要剪辑的素材时则应选择恒定帧率。</p>

            <h2 id="h2-2">编解码的过程</h2>
            <h3>视频的打开</h3>
            <ol>
                <li>用户点击打开视频文件</li>
                <li>操作系统根据文件扩展名，查找默认的应用程序</li>
                <li>应用程序根据文件路径，在文件系统中定位视频，并读取文件的元数据，包括文件头和其他格式信息</li>
                <li>应用程序根据文件的元数据确定所需的解码器和其他资源，然后在计算机的内存中分配空间</li>
                <li>应用程序调用适当的解码器来解析视频文件，并将视频和音频数据解码为未压缩的原始数据</li>
                <li>解码后的视频数据传递给图形处理芯片 GPU，而音频数据则传递给声音转换芯片 DAC。</li>
                <li>GPU 将图像信号转换为图像，输出到显示器</li>
                <li>显示器上的芯片将图像数据转换为对每个像素上电路的控制，并显示出来</li>
                <li>DAC 将音频信号转换为模拟信号，并通过扬声器播放出来</li>
            </ol>
            <p>此步骤涵盖了基本的视频打开过程，在实际情况下会因为软硬件，用户设定，以及操作系统逻辑的不同而有出入。</p>

            <h3>视频的压制</h3>
            <ol>
                <li><b>打开编码器</b>
                    <ul>
                        <li>用户可以通过多种方法打开编码器：
                            <ul class="text-smaller">
                                <li>如果编码器内置了如 Lavf 的解封装和解码动态链接库，则编码器可以自动解封装、解码和封装视频文件：
                                    <ul class="text-smaller">
                                        <li>GUI 软件通过发送 CLI 命令，或者使用像 Bash/CMD 这样的 CLI 工具来打开编码器程序。</li>
                                        <li>编码器通常根据输出文件的后缀名自动封装视频文件。</li>
                                    </ul>
                                </li>
                                <li>如果编码器没有内置解封装解码功能，则通常会使用 ffmpeg 内部的解封装工具和编码器。
                                    <ul>
                                        <li>可以使用 pipe 将上游如 ffmpeg、VapourSynth、avs2yuv 连接到下游如 x264/5 的编码器</li>
                                    </ul>
                                </li>
                            </ul>
                        </li>
                    </ul>
                </li>
                <li><b>解封装和解码</b>
                    <ul>
                        <li>解封装解码工具将已解压缩的 YUV for MPEG 或 RAW 格式视频流传递给编码器，编码器得到输入信号。
                            <ul class="text-smaller">
                                <li>如果输入是 RGB24 的 RAW 色彩空间视频流，通常需要使用编码器内置的色彩空间转换功能将其转换为 YUV 格式。</li>
                                <li>如果编码器是录像设备的一部分，则需要根据录像设置将视频流拆分为视频帧。</li>
                            </ul>
                        </li>
                    </ul>
                </li>
                <li><b>编码过程</b>
                    <ul>
                        <li><b>前瞻进程</b>：Lookahead 从更小的分辨率预先分析未来几帧的复杂度、运动和场景切换 scenecut 的估计。</li>
                        <li><b>分帧/帧类型决策</b>：根据前瞻进程的结果和关键帧间隔 keyframe interval 设置关键帧 I 帧与参考帧 P-B 帧。</li>
                        <li><b>粗分块</b>：
                            <ul>
                                <li>x264 中粗分到宏块 Macroblock MB</li>
                                <li>x265 中粗分到编码树单元 Coding Tree Unit CTU </li>
                            </ul>
                        </li>
                        <li><b>动态搜索</b>：Motion Estimation ME 找到当前帧与参考帧之间的相似区域，并为每个块分配动态向量。</li>
                        <li><b>运动补偿</b>：Motion Compensation MC 对比实际画面与搜索到的向量生成预测块，并补偿¼子像素精度的对齐偏差。</li>
                        <li><b>细分块</b>：根据 MEMC，进一步细分宏块或编码树单元到最小的 4x4 编码块上。</li>
                        <li><b>帧间残差编码</b>：对比实际画面与动态搜索与补偿后所得的图像，得到残差，并对残差进行变换和量化，存储到 P-B 帧上，在解码时与 I 帧叠加以得到原始画面。</li>
                        <li><b>帧内预测</b>：在 I 帧或 P 帧的 I 块上，从前面步骤中生成的候选夹角、DC、趋平中的最佳模式冗余帧内的块，得到预测块。</li>
                        <li><b>帧内残差编码</b>：对比实际画面与帧内预测得到的残差块，进行变换和量化，存储在预测块中，在解码时与预测模式叠加以得到原始画面。</li>
                        <li><b>跳过块编码</b>：跳过帧间或帧内残差编码的块，进行变换和量化。</li>
                        <li><b>变换</b>：将图像从空间域转换到低频到高频信号分量之间的每个级别，也称为频域。</li>
                        <li><b>量化</b>：根据用户设置的质量级别，削减高频信号分量，这一步骤对画质和文件大小影响最大。</li>
                        <li><b>熵编码/文本编码</b>：将变换和量化后的频域分量统计为最小可能的二进制数。</li>
                    </ul>
                </li>
                <li><b>生成视频流</b>
                    <ul>
                        <li>编码器将生成的数据流逐个 GOP Group of Pictures 打包，并附加如色彩空间、Supplemental Enhancement Information SEI、Video
                            Usability Information/High Dynamic Range VUI/HDR 等元数据，得到视频流。</li>
                    </ul>
                </li>
                <li><b>封装视频流</b>
                    <ul>
                        <li>用户可以通过多种方法将视频流封装为 .mp4、.mkv、.mov 等格式：
                            <ul class="text-smaller">
                                <li>如果编码器内置了像 Lavf 的解封装解码动态链接库，编码器可以根据输出命令行的文件后缀名自动完成。</li>
                                <li>如果编码器没有内置解封装解码功能，则通常会使用 ffmpeg 内部的编码器和解封装工具，使编码完成后自动封装。</li>
                                <li>可以使用工具如 <a href="http://ffmpeg.org/download.html">ffmpeg</a>、<a href="https://www.videohelp.com/software/MP4Box">MP4Box</a>，<a href="https://mkvtoolnix.download/">MKVToolNix</a> 等来进行封装。</li>
                            </ul>
                        </li>
                    </ul>
                </li>
            </ol>
            <div class="align-items-center">
                <img src="files/basics/Video-Endocing-Process.png" alt="image18" class="img-medium">
            </div>

            <h3>视频编码的标准（<a href="https://developer.mozilla.org/en-US/docs/Web/Media/Formats/Video_codecs">MDN Docs</a>）</h3>
            <p>编码的标准 Encoding Standard 一般称为 coding 或 codec。其中 code 即代码，其末尾加 c 是一种名词化的形容词，如 politic/political，magic/magical，electric/electrical。</p>
            <div class="overflow-auto">
                <table class="table-center align-items-center text-smaller">
                    <thead>
                        <tr>
                            <th scope="row">♙编码</th>
                            <th scope="col">全程</th>
                            <th scope="col">一般封装格式</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr class="border-bottom">
                            <th scope="row">AV1</th>
                            <td>AOMedia Video 1</td>
                            <td>MP4，WebM，MKV</td>
                        </tr>
                        <tr class="border-bottom">
                            <th scope="row">AVC (H.264)</th>
                            <td>Advanced Video Coding</td>
                            <td>3GP，MP4</td>
                        </tr>
                        <tr class="border-bottom">
                            <th scope="row">H.263</th>
                            <td>H.263 Video</td>
                            <td>3GP</td>
                        </tr>
                        <tr class="border-bottom">
                            <th scope="row">HEVC (H.265)</th>
                            <td>High Efficiency Video Coding</td>
                            <td>MP4</td>
                        </tr>
                        <tr class="border-bottom">
                            <th scope="row">MP4V-ES</th>
                            <td>MPEG-4 Video Elemental Stream</td>
                            <td>3GP，MP4</td>
                        </tr>
                        <tr class="border-bottom">
                            <th scope="row">MPEG-1</th>
                            <td>MPEG-1 Part 2 Visual</td>
                            <td>MPEG，QuickTime</td>
                        </tr>
                        <tr class="border-bottom">
                            <th scope="row">MPEG-2</th>
                            <td>MPEG-2 Part 2 Visual</td>
                            <td>MP4，MPEG，QuickTime</td>
                        </tr>
                        <tr class="border-bottom">
                            <th scope="row">Theora</th>
                            <td>Theora</td>
                            <td>Ogg</td>
                        </tr>
                        <tr class="border-bottom">
                            <th scope="row">VP8</th>
                            <td>Video Processor 8</td>
                            <td>3GP，Ogg，WebM</td>
                        </tr>
                        <tr>
                            <th scope="row">VP9</th>
                            <td>Video Processor 9</td>
                            <td>MP4，Ogg，WebM</td>
                        </tr>
                    </tbody>
                </table>
            </div>
            <p>其中，“H.264”的 H 代表国际电信联盟 - 电信标准化部门（ITU‑T）中的 <a href="https://www.itu.int/net/itu-t/sigdb/spevideo/Hseries-s.htm">H 系列建议指南</a>。如 <a href="https://www.itu.int/rec/T-REC-H.810">ITU-T H.810</a> 个人健康系统（血压计、血糖仪、体重秤之类）的交互设计建议指南。一些符合某个 H 系列视频编码建议指南的视频编码器会将这个标号写在程序名字上，就有了所谓的 x264，x265。</p>
            <div class="align-items-center">
                <img src="files/basics/Video-Endocing-Standards.png" alt="image19" class="img-medium">
            </div>

            <h3>命令行参数</h3>
            <p>由开发者定义，将函数或程序中的一些变量设为通过命令传递。命令行参数一般使用空格作为分隔符（也有用半角冒号，半角句号等其他情况），参数和参数值之间一般使用空格做分隔符（也有使用等于号的其他情况），多个参数值之间一般使用半角逗号或半角冒号分隔，而含有空格的参数值则使用半角直引号 "" 或 '' 连起来。</p>
            <p>例如，x264 使用 CLI 参数的例子：</p>
            <code>x264.exe <span class="text-blue-emph">--rc-lookahead 90 --bframes 12 --b-adapt 2 --me umh --subme 9 --merange 48 --no-fast-pskip --direct auto --weightb --keyint 360 --min-keyint 5 --ref 3 --crf 20 --qpmin 9 --chroma-qp-offset -2 --aq-mode 3 --aq-strength 0.7 --trellis 2 --deblock 0:0 --psy-rd 0.77:0.22 --fgo 10 --nr 4</span> --output ".\输出.mp4" ".\导入.mp4"</code>
            <p>以及 ffmpeg 中使用 CLI 参数启用 libx264，通过 <code>-x264-params</code> 发送 API 参数的例子：</p>
            <code>ffmpeg.exe -loglevel 16 -hwaccel auto -y -hide_banner -i ".\导入.mp4" -c:v libx264 -x264-params "<span class="text-blue-emph">rc-lookahead=90:bframes=12:b-adapt=2:me=umh:subme=9:merange=48:fast-pskip=0:direct=auto:weightb=1:keyint=360:min-keyint=5:ref=3:crf=20:qpmin=9:chroma-qp-offset=-2:aq-mode=3:aq-strength=0.7:trellis=2:deblock=0,0:psy-rd=0.77,0.22:nr=4</span>" -fps_mode passthrough -c:a copy ".\输出.mp4"</code>
            <p>ffmpeg 中，导入文件由 <code>-i</code> 参数完成，因为 ffmpeg 支持导入多个文件，而每个文件后跟随一些处理命令就需要较为严格的命令添加顺序，而 x264/5 这些编码器一般只是导入一个文件，所以在末尾加一个路径到文件的字符串就代表导入文件了。</p>

            <h3>本教程中命令行参数的说明格式</h3>
            <code><b>--参数</b></code>
            <p class="font-monospace pl-5 m-0 overflow-auto">&lt;开关 | 整数 A~B | 浮点 A~B | 其它格式，默认值，<span class="text-red-emph">限制</span>&gt; 说明信息，特点注解，推荐<span class="text-blue-emph">这个值</span>，其它情况可设<span class="text-blue-emph">这个值</span>。</p>
            <ul class="font-monospace pl-5 text-smaller">
                <li>情况 1：特点如此，推荐<span class="text-blue-emph">这个值</span></li>
                <li>情况 2：特点如此，推荐<span class="text-blue-emph">这个值</span></li>
                <li>情况 3：特点如此，推荐<span class="text-blue-emph">这个值</span></li>
            </ul>

            <h3>管道 Pipeline</h3>
            <p>在进程/软件之间通信的操作系统机制。在 CLI 中表现为两个程序的命令通过链接符 <span class="text-blue-emph">|</span> 串联起来。常用于将上游程序/协议/函数输出的信息传递给下游程序/协议/函数实现过滤。最早的形式为 <a href="https://zh.wikipedia.org/wiki/%E7%AE%A1%E9%81%93_(Unix)">Unix Pipe</a>。管道中程序/协议/函数的默认输入，输出与报错分别叫做 stdin，stdout，stderr，它们可以被手动指定到特定的路径，或作为管道传给更下游的程序/协议/函数。</p>
            <h4>串流管道 Stream-based pipeline</h4>
            <p>管道中的程序同步运行，持续地传输上游输出到下游。适用于串流作业和处理流数据，包括视音频和文本流。</p>
            <h4>对象管道 Object-based pipeline</h4>
            <p>管道中的程序按顺序接力，一个程序/协议/函数跑完后再打开下一个。适用于处理对象化的数据，面向对象的应用程序。Windows PowerShell 使用了对象管道，所以不适合处理视音频流文件。</p>
            <h4>指定默认输入和报错</h4>
            <p>在不默认从 stdin 读取管道上游 stdout 的程序/协议/函数，以及不默认从 stdout 输出数据流的程序/协议/函数中，需要添加“-”以特别指定上游输出到 stdout，下游从 stdin 输入，就有了这样的命令行参数：</p>
            <code>ffmpeg -i &lt;源&gt; -an -f yuv4mpegpipe -strict unofficial <span class="text-blue-emph">- |</span> x265 --y4m <span class="text-blue-emph">-</span> --output</code>

            <h2 id="h2-3">数据结构</h2>
            <h3>帧的结构</h3>
            <p>在 Advanced Video Coding AVC 中，帧的下级结构按照分辨率大小分为条带组 slice group → 条带 slice → 宏块 Macroblock → 块 block。从大小和功能上细分为：</p>
            <ul>
                <li><b>帧 frame</b>：
                    <ul class="text-smaller">
                        <li><b>关键帧</b>：I/i 帧</li>
                        <li><b>参考帧</b>：P 帧、B/b 帧</li>
                    </ul>
                </li>
                <li><b>条带组 slice group</b>：
                    <ul class="text-smaller">
                        <li>由灵活宏块排序 Flexible Macroblock Ordering FMO 划分</li>
                        <li>优化解码延迟，提高压缩和参考错误恢复能力</li>
                    </ul>
                </li>
                <li><b>条带 slice</b>：
                    <ul class="text-smaller">
                        <li><b>关键帧下</b>：I/i 条带</li>
                        <li><b>参考帧下</b>：I/i 条带、P 条带、B/b 条带</li>
                        <li>空条带：填充网络数据包中，数据不足而无法填满的空位</li>
                        <li>冗余条带：提高数据抗丢包，抗损坏的能力</li>
                    </ul>
                </li>
                <li><b>宏块 Macroblock</b>：
                    <ul class="text-smaller">
                        <li>粗分块，在动态搜索与补偿前完成，面积为 16x16 像素</li>
                    </ul>
                </li>
                <li><b>块 Block</b>：
                    <ul class="text-smaller">
                        <li>细分块，在动态搜索与补偿后完成，面积为 8x8 或 4x4 像素</li>
                        <li><b>关键帧下</b>：帧内预测块、帧间预测块</li>
                        <li><b>参考帧下</b>：帧内预测块、帧间预测块、帧内残差块、帧间残差块</li>
                        <li>帧间预测块：将 I 块叠加帧间动态矢量后变出的帧间预测画面</li>
                        <li>帧内预测块：从块左侧和顶部的一排相邻像素上，叠加插值算法变出的帧内预测画面</li>
                        <li>残差块：保存帧间和帧内预测无法还原的信息，与预测宏块叠加用。画面复杂则“残差才是本体”</li>
                    </ul>
                </li>
            </ul>
            <div class="align-items-center">
                <img src="files/basics/Video-Coding-Components.png" alt="image20" class="img-medium">
            </div>

            <h3>GOP 的结构</h3>
            <p>而相对的，在帧之上的结构被称为图组 Group of pictures。每个 GOP 的创建取决于关键帧间隔设置以及转场判断，其中都包含了 IDR 帧，i 帧，P 帧，Pyramid-B 帧以及 b 帧。一个视频中最少由一个 GOP 组成，同视频长度下 GOP 的数量越多则视频体积越大，解码难度越低。</p>
            <ul>
                <li><b>关键帧 IDR 帧，I 帧</b>：
                    <ul>
                        <li><b>I 帧 Intra-coded frame</b>独立编码，不依赖于其他帧的关键帧。也可以作为解码的起始点，只是不会刷新参考帧列表，所以强行播放可能会有一些画面错误
                            <ul class="text-smaller">
                                <li>“关键”代表“起到独立解码，随机访问点 Access point，传输错误后重新同步视频流，集中参考源以提高压缩率等关键作用”</li>
                            </ul>
                        </li>
                        <li><b>即时解码刷新 Instantaneous Decoder Refresh 帧</b>是一种带有刷新标记的特殊 I 帧，解码器播放到 IDR 帧时会刷新参考帧列表，因此 IDR 帧之前的帧不再作为参考源，从而隔离了 GOP。</li>
                        <li>IDR 帧一般位于 GOP（Group of Pictures）之首。用户拖动进度条时，解码器会寻找最近的 IDR 帧解码</li>
                        <li>IDR 帧与 I 帧同为关键帧，有时会被写作 I 帧与 i 帧</li>
                        <li>IDR 帧数量过少时，可能会导致以下问题：
                            <ul class="text-smaller">
                                <li>随机访问会导致参考错误 + 长时间无法纠正画面错误：P，B，b 帧会尝试参考 i 帧之前的帧</li>
                                <li>剪辑困难：专业视频编辑软件会在剪辑视频时会插入新的 IDR 帧以保证预览流畅和准确</li>
                                <li>随机访问困难，因为 GOP 的基础结构不存在，拖动进度条需要从视频开头解码到新的位置以后才能播放</li>
                                <li>拖动进度条代表需要从很远的 IDR 帧（无 IDR 帧则从视频开头）解码到新的位置再继续，等待的时间变得漫长，播放设备的发热增加</li>
                                <li>如果播放器关闭了拖动进度条的精确索引，则拖动进度条会导致进度条位置偏移到其之前很远的 IDR 帧上，或返回开头</li>
                            </ul>
                        </li>
                        <li>如果 I 帧数量过少，则会有一串含有 I 条带的 P 帧替代它</li>
                        <li>IDR 帧的数量由 Keyframe interval <code>--keyint</code> 参数和 <code>--scenecut</code> 参数决定</li>
                        <li>I 帧的数量由 <code>--min-keyint</code> 参数决定</li>
                    </ul>
                </li>
                <li><b>参考帧 P/B-Pyramid/b 帧</b>：
                    <ul class="text-smaller">
                        <li>参考帧 P 帧 Prediction frame 含有 I 条带与 P 条带，全部条带都可以给临近的 P，B 帧参考</li>
                        <li>双向参考帧 Bi-directional prediction frame，b 帧含有 i，P，B 条带，只有 i 条带可以给临近的 P，B 帧参考</li>
                        <li>尖塔 B 帧 Pyramid bi-directional prediction frame 含有 I，P，B 条带，全部条带都可以给临近的 P，B 帧参考</li>
                    </ul>
                </li>
            </ul>

            <h4>多参考帧的结构</h4>
            <p>x264 首次引入了超过前后一帧长度的帧间参考范围。因此动态搜索也能更好的检查运动向量的时间一致性，从而减少动态噪点对动态搜索的干扰，同时提高了压缩。多参考帧不是越长越好，而是只要满足「一帧只要参考前后各 n 帧的信息就足以还原自身」的长度就是对的，而超过后会导致视频体积增加，同时画质降低。这个长度一般是前后各 3 帧，</p>

            <h2 id="h2-4">编码 - 前瞻进程 Lookahead</h2>
            <p>最先启动，设立关键帧和参考帧，决定了 GOP 划分的初始编码步骤。决定了后续所有步骤的大纲：</p>
            <ol>
                <li><b>启动和初始化</b>：
                    <ul>
                        <li>从视频或 <code>--seek</code> 参数指定的位置开始，顺序导入视频帧到 Lookahead 过程</li>
                        <li>导入的视频帧会被缩小一半以提高速度</li>
                        <li>后续步骤发现 GOP 结尾时，当前的 Lookahead 帧列表（<code>h-&gt;Lookahead-&gt;next-&gt;list</code> ）会更新 Lookahead 起点。</li>
                    </ul>
                </li>
                <li><b>软转场（Scenecut）</b>：
                    <ul>
                        <li>如果输入的首帧是自动 AUTO 模式或 I 帧，则设为 IDR 帧</li>
                        <li>如果使用 <code>--no-open-gop</code>，且输入帧与之前的非 B 帧画面差距达到 <code>--scenecut</code> 阈值触发转场，则设立 IDR 帧以建立新的 GOP</li>
                        <li>IDR 帧（于 <code>--min-keyint</code> 范围内则设 I 帧）的前一帧会被强制改为 P 帧，以阻止 B 帧的双向参考特性</li>
                    </ul>
                </li>
                <li><b>启用/关闭连续 B 帧</b>：
                    <ul>
                        <li>排除了设立 I/i 帧的可能后，还剩下 GOP 长度减 1 的帧数量没有被分配帧类型。此时不考虑 Pyramid-B 帧，所以这些帧可以是 IDR/i/P/B 帧。如果设 IDR 帧则 GOP 收尾</li>
                        <li>根据 <code>--b-adapt</code> 指定的算法和 <code>--bframes</code> 的最大连续 B 帧长度，区分出 P 帧和 B 帧，得到如 PBBBPBP 的序列</li>
                        <li><code>--b-pyramid</code> 参数允许连续 B 帧中的偶数帧作为参考帧使用，保证了长距离的连续 B 帧</li>
                    </ul>
                </li>
                <li><b>维特比算法推演 P/B/b 帧</b>：
                    <button type="button" class="collapsible border-main rounded-3">点击展开/折叠内容：维特比算法的推演例子，可略</button>
                    <ul class="coll-content">
                        <li>Viterbi shortest path 是一种多起点 - 多终点，类似于 A*和 Dijkstra 的最短路径算法。假设一种成本模型：
                            <ul>
                                <li>I 帧成本最高，记为设立成本 <span class="text-blue-math">\(cost_I=10\)</span>；I 帧后的非 I 帧成本 +1，记为转换成本 <span class="text-blue-math">\(cost_{IS}=1\)</span></li>
                                <li>P 帧成本次之，记为设立成本 <span class="text-blue-math">\(cost_P=5\)</span>；P 帧后的非 P 帧成本 +1，记为转换成本 <span class="text-blue-math">\(cost_{PS} = 1\)</span></li>
                                <li>B 帧成本最低，记为设立成本 <span class="text-blue-math">\(cost_B=2\)</span>；B 帧压缩最高，记为转换成本 <span class="text-blue-math">\(cost_{BS} = 0\)</span></li>
                                <li><code>--ref</code> 参数设定了参考帧的最远范围，使编码器不总选择成本最低的 B 帧</li>
                            </ul>
                        </li>
                        <li>应用到推演各帧的可能路径图：
                            <ul class="text-gray-side">
                                <li>Frame 0: I0, -, -（GOP 首帧只能是路径中的 I 帧）</li>
                                <li>Frame 1: I1, P1, B1</li>
                                <li>Frame 2: I2, P2, B2</li>
                                <li>Frame 3: I3, P3, B3</li>
                                <li>Frame 4: I4, P4, B4</li>
                                <li>...</li>
                            </ul>
                        </li>
                        <li>由此推演第 0，第 1 帧的成本，其中<span class="text-blue-math">\(cost(I_0)\)</span>代表第 0 帧为 I 帧的成本，<span class="text-blue-math">\(cost(I)\)</span>代表设立 I 帧的成本，则记为转换成本（当然此处严格一些应该直接写成 1）：
                            <ul class="text-gray-side">
                                <li>Frame 0: <span class="text-blue-math">\(10\)</span>, <span class="text-blue-math">\(\text{-}\)</span>, <span class="text-blue-math">\(\text{-}\)</span></li>
                                <li>Frame 1: <span class="text-blue-math">\(cost_{I0} + 10\)</span>, <span class="text-blue-math">\(cost_{P0} + cost_{IS} + 5\)</span>, <span class="text-blue-math">\(cost_{B0} + cost_{IS} + 2\)</span></li>
                                <li>Frame 1: 20, 16, 13，或 <span class="text-blue-math">\(cost_{I1} = 20\)</span>，<span class="text-blue-math">\(cost_{P1} = 16\)</span>，<span class="text-blue-math">\(cost_{B1} = 13\)</span></li>
                            </ul>
                        </li>
                        <li>正式采用维特比算法——选择每个帧的成本变为枝梢计算：设立成本 + 上帧三条路径中的最小值，推演第 2 帧及其后帧的成本：
                            <ul>
                                <li><span class="text-blue-math">\(I2 = min(cost_{I1} + 10, cost_{P1} + cost_{PS} + 10, cost_{B1} + 10) = min(20 + 10, 16 + 1 + 10, 13 + 10) = min(30,27,23) = 23\)</span></li>
                                <li><span class="text-blue-math">\(P2 = min(cost_{I1} + cost_{IS} + 5, cost_{P1} + 5, cost_{B1} + 5) = min(20 + 1 + 5, 16 + 5, 13 + 5) = min(26,21,18) = 18\)</span></li>
                                <li><span class="text-blue-math">\(B2 = min(cost_{I1} + cost_{IS} + 2, cost_{P1} + cost_{PS} + 2, cost_{B1} + 2) = min(20 + 1 + 2, 16 + 1 + 2, 13 + 2) = min(23,19,15) = 15\)</span></li>
                                <li class="text-gray-side">Frame 2: 23, 18, 15</li>
                                
                                <li><span class="text-blue-math">\(I3 = min(cost_{I2} + 10, cost_{P2} + cost_{PS} + 10, cost_{B2} + 10) = min(23 + 10, 18 + 1 + 10, 15 + 10) = min(33,29,25) = 25\)</span></li>
                                <li><span class="text-blue-math">\(P3 = min(cost_{I2} + cost_{IS} + 5, cost_{P2} + 5, cost_{B2} + 5) = min(23 + 1 + 5, 18 + 5, 15 + 5) = min(29,23,20) = 20\)</span></li>
                                <li><span class="text-blue-math">\(B3 = min(cost_{I2} + cost_{IS} + 2, cost_{P2} + cost_{PS} + 2, cost_{B2} + 2) = min(23 + 1 + 2, 18 + 1 + 2, 15 + 2) = min(26,21,17) = 17\)</span></li>
                                <li class="text-gray-side">Frame 3: 25, 20, 17</li>

                                <li><span class="text-blue-math">\(I4 = min(cost_{I3} + 10, cost_{P3} + cost_{PS} + 10, cost_{B3} + 10) = min(25 + 10, 20 + 1 + 10, 17 + 10) = min(35,31,27) = 27\)</span></li>
                                <li><span class="text-blue-math">\(P4 = min(cost_{I3} + cost_{IS} + 5, cost_{P3} + 5, cost_{B2} + 5) = min(25 + 1 + 5, 20 + 5, 17 + 5) = min(26,25,22) = 22\)</span></li>
                                <li><span class="text-blue-math">\(B4 = min(cost_{I3} + cost_{IS} + 2, cost_{P3} + cost_{PS} + 2, cost_{B2} + 2) = min(25 + 1 + 2, 20 + 1 + 2, 17 + 2) = min(28,23,19) = 19\)</span></li>
                                <li class="text-gray-side">Frame 3: 27, 22, 19</li>
                                <li class="text-gray-side">Frame 4: 29, 24, 21</li>
                            </ul>
                        </li>
                        <li>将复杂度（前后两帧画面差距）视作分母 <span class="text-blue-math">\(cplx_{0→1}\)</span>，将路径的值视作分子，就得到了该简化例子下的路径成本：
                            <ul class="text-gray-side">
                                    <li>Frame 0: I0, -, -（GOP 首帧只能是路径中的 I 帧）</li>
                                    <li>Frame 1: <span class="text-blue-math">\(\frac{cplx_{1→2}}{I1}\)</span>, <span class="text-blue-math">\(\frac{cplx_{0→1}}{P1}\)</span>, <span class="text-blue-math">\(\frac{cplx_{0→1}}{B1}\)</span></li>
                                    <li>Frame 2: <span class="text-blue-math">\(\frac{cplx_{2→3}}{I2}\)</span>, <span class="text-blue-math">\(\frac{cplx_{1→2}}{P2}\)</span>, <span class="text-blue-math">\(\frac{cplx_{1→2}}{B2}\)</span></li>
                                    <li>Frame 3: <span class="text-blue-math">\(\frac{cplx_{3→4}}{I3}\)</span>, <span class="text-blue-math">\(\frac{cplx_{2→3}}{P3}\)</span>, <span class="text-blue-math">\(\frac{cplx_{2→3}}{B3}\)</span></li>
                                    <li>Frame 4: <span class="text-blue-math">\(\frac{cplx_{4→5}}{I4}\)</span>, <span class="text-blue-math">\(\frac{cplx_{3→4}}{P4}\)</span>, <span class="text-blue-math">\(\frac{cplx_{3→4}}{B4}\)</span></li>
                                    <li>...</li>
                            </ul>
                        </li>
                        <li>如此一来，编码器就能得知什么时候设什么帧了</li>
                    </ul>
                </li>
                <li><b>MBTree 搜索</b>：
                    <ul>
                        <li>分析时间空间范围内的块分布，找出少见的宏块，并计算出这些块的压缩强度偏移，以提高这些块的压缩</li>
                        <li>偏移程度的计算考虑了 Lookahead 中快速动态预测的准确度（当前和未来两帧相减，差距越大越复杂）</li>
                        <li>偏移程度的计算还考虑了当前帧与软转场 GOP 首帧的距离，距离越远越少见，分配的压缩强度越大</li>
                        <li>在这之前的软转场已将画面分界，所以“距离远”代表画面不变的情况下的距离远</li>
                    </ul>
                </li>
                <li><b>硬转场（keyint）</b>：
                    <ul>
                        <li>（等 mbtree 完成后）如果使用 <code>--no-open-gop</code>，且当前 GOP 长度达 <code>--min-keyint</code> 大小，则设立 IDR 帧以建立新的 GOP</li>
                        <li>IDR 帧（于 <code>--min-keyint</code> 范围内则设 I 帧）的前一帧会被强制改为 P 帧，以阻止 B 帧的双向参考特性</li>
                    </ul>
                </li>
                <li><b>量化值预设</b>：
                    <ul>
                        <li>根据 <code>--rc-lookahead</code> 参数指定的长度为一组，通过当前和未来两帧相减，得到差值，以大致分配压缩强度</li>
                    </ul>
                </li>
                <li><b>VBV/VBR 码率限制</b>：见<a href="../../x265-web-tutorial/HTML/index.html#h2-8">x265 教程网页版</a></li>
            </ol>

            <code><b>--min-keyint</b></code>
            <p class="font-monospace pl-5 m-0 overflow-auto">&lt;整数，默认 25，<span class="text-red-emph">小于等于 keyint</span>&gt;判断新发现的转场距离上个 IDR 帧是否小于该值长短。有两种设定逻辑，而它们给出的画质都一样：</p>
            <ul class="font-monospace pl-5 text-smaller">
                <li>一般通用，一定程度上防止硬转场干扰软转场的溯块参考冗余：<span class="text-blue-emph">keyint ÷2</span></li>
                <li>少设一些 IDR 帧，以略微提高压缩率和编码速度<span class="text-blue-emph">5 或更高</span></li>
                <li>快速编码/直播环境：<span class="text-blue-emph">等于 keyint</span></li>
                <li>多设一些 IDR 帧，一帧被判做转场本来就意味着前后溯块的价值不高。损失编码速度和压缩率，使复杂画面更接近素材视频级的图片序列，从而分配更多的码率 <span class="text-blue-emph">1 或 2</span></li>
            </ul>
            <code><b>--keyint</b></code>
            <p class="font-monospace pl-5 m-0 overflow-auto">&lt;整数&gt;一般设 <span class="text-blue-emph">9 倍于帧率</span>（9 秒一个 IDR 帧），影响视频解码计算难度和拖进度条的延迟：</p>
            <ul class="font-monospace pl-5 text-smaller">
                <li>短视频，不拖进度条的视频：<span class="text-blue-emph">keyint -1</span>略微降低文件体积</li>
                <li>剪辑素材，频繁于多个视频轨上，根据画面复杂度设<span class="text-blue-emph">5 倍于帧率</span>，以降低解码负载</li>
            </ul>
            <code><b>--ref</b></code>
            <p class="font-monospace pl-5 m-0 overflow-auto">&lt;整数 1~16, 推荐 <span class="text-blue-emph">3</span> 或 <span class="text-blue-math">\(1\%\times \text{fps} + 3.4\)</span>&gt;多参考帧前后帧数半径，一图流设 <span class="text-blue-emph">1</span>。必须要在溯全尽可能多块的情况下降低参考长度，所以推荐 <span class="text-blue-emph">3</span>：</p>
            <code><b>--no-mixed-refs</b></code>
            <p class="font-monospace pl-5 m-0 overflow-auto">&lt;开关&gt;关闭参考帧混合溯块（16×8，8×8 分块的参考）以提速，增加误参考。不推荐</p>
            <code><b>--scenecut</b></code>
            <p class="font-monospace pl-5 m-0 overflow-auto">&lt;整数，不推荐用&gt; Lookahead 中两帧差距达到该参数值则触发转场。</p>

            <h2 id="h2-5">动态搜索</h2>
            <!-- x265 教程副本，更改需手动同步 { -->
            <p>Motion Estimation。用于在连续帧间进行运动估计。过程涉及逐个像素点（微观）在相邻帧之间寻找最小失真朝向/最小失真方向 Direction of minimal distortion DMD，从而在每帧之间都生成一张向量表。如果这个过程缺失或不够理想，参考帧与分块的建立就可能会出现问题，从而导致潜在的压缩率损失或画质下降。</p>
            <div class="align-items-center">
                <img src="files/memc/Interframe-Vector-Table.png" alt="image21" class="img-medium">
                <p class="text-gray-side">图：宏块上帧间的动态向量</p>
            </div>
            <p>简化模型下，动态搜索得到帧间向量表，帧间向量表加上上帧的画面得到预测帧，原始帧减去预测帧得到残差帧，残差帧储存为参考帧，得到帧间结构。x264 使用了不对称多六边形搜索 Uneven multiple Hexagon，从而让一个搜索算法在多个分辨率下检查画面，制衡了动态噪点对传统动态搜索算法的干扰。搜索算法详见 <a href="../../x265-web-tutorial/HTML/index.html#h2-5">x265 教程</a>。</p>
            <!-- } -->
            <code><b>--me</b></code>
            <p class="font-monospace pl-5 m-0 overflow-auto">&lt;hex/umh/esa/tesa，推荐 umh&gt; 搜索算法，umh 平衡，star 四角星搜索之后收益递减，sea 是优化过的 x264 esa 穷举，但收益递减仍大。umh 通过多种分辨率大小的查找范围，减轻了动态噪点对传统搜索算法的干扰</p>
            <code><b>--merange</b></code>
            <p class="font-monospace pl-5 m-0 overflow-auto">&lt;整数，推荐 4 的倍数，<span class="text-red-emph">需 me</span>&gt; <span class="text-blue-emph">完全取决于 ME 算法和分辨率</span>，过大会因「找不到更好，找到也是错」而损失画质和压缩。</p>
            <ul class="font-monospace pl-5 text-smaller">
                <li>1920x1080 下推荐<span class="text-blue-emph">48</span>左右</li>
                <li>3840x2160 下推荐<span class="text-blue-emph">52</span>左右</li>
                <li>me hex 下设<span class="text-blue-emph">16</span></li>
                <li>me umh 设<span class="text-blue-emph">≥32</span></li>
            </ul>
            <code><b>--no-fast-pskip</b></code>
            <p class="font-monospace pl-5 m-0 overflow-auto">&lt;开关，推荐开&gt; 关闭跳过编码 P 帧的功能</p>
            <code><b>--direct</b></code>
            <p class="font-monospace pl-5 m-0 overflow-auto">&lt;temporal/spatial/auto&gt; 指定动态搜索判断方式的参数，除直播和低性能设备录屏外建议 auto</p>
            <code><b>--non-deterministic</b></code>
            <p class="font-monospace pl-5 m-0 overflow-auto">&lt;开关，推荐开&gt; 降低完算性，让新的动态搜索线程得知「旧动态搜索线程线程实际搜素过，而非参数设定」的区域。理论上会使新线程排除一些范围从而提速，而「完算性」仅代表通过完整计算得到结果，而不是提前跳过的计算特征。启用多线程，VBV 都会降低完算性</p>
            <code><b>--no-chroma-me</b></code>
            <p class="font-monospace pl-5 m-0 overflow-auto">&lt;开关，推荐直播/录屏用&gt; 跳过色度平面动态搜索，将亮度平面直接应用。可能对画质有略微负面影响</p>
            <!-- x265 教程副本，更改需手动同步 { -->
            <h3>绝对变换差和 SATD</h3>
            <p>Sum of absolute transformed difference 为两个变换块间做差，取和，取绝对值的步骤：</p>
            <ol>
                <li>首先计算两个块 B 的插值，记做残差块 D：<span class="text-blue-math">\(\text{D}(x,y) = B(x,y) - B\prime(x,y)\)</span></li>
                <li>然后通过哈达码变换（相比 DCT 节约算力），得到变换残差块：<span class="text-blue-math">\(T(D)\)</span>
                    <ul><li>省略这一步，则算法叫做绝对差 Sum of absolute difference SAD</li></ul>
                </li>
                <li>最后，变换残差块的每个像素取绝对值和：<span class="text-blue-math">\(\text{SATD}(B,B\prime) = \sum_{x=0}^{n-1}{\sum_{y=0}^{n-1}}| T(D(x,y)) |\)</span></li>
            </ol>
            <p class="text-gray-side">注：为了简化所以写作 <span class="text-blue-math">\(T(D(x,y))\)</span>，实际这样相当于每加一个像素值就要变换一遍</p>

            <h2 id="h2-6">子像素运动补偿</h2>
            <p>动态预测的精度最高只有 1px，在此之上还有可能被动态噪点干扰，导致了预测帧相比原画会欠缺大量的纹理细节。动态补偿 Motion Compensation MC 通过对比原画与预测块得到残差，并根据残差的分布动态向量的精度到¼子像素，使“精加工预测块”的画面残差尽可能地缩小，得到足够准确的预测帧，即大幅减少残差帧的内容。</p>
            <div class="align-items-center">
                <img src="files/memc/Block-Spitting-Stage-Two.png" alt="image22" class="img-medium">
                <p class="text-gray-side">图：根据动态搜索与补偿所得，完成宏块到块的细分</p>
            </div>
            <p>至于对抗动态噪点，大体上是允许真正移动的物件（所涵盖的分块）有运动向量，拦截噪点在静止画面上的孤立运动向量，即「允动之移，防静所变」解决，详见 <a href="../../x265-web-tutorial/HTML/index.html#h2-6">x265 教程</a>。</p>
            <ol class="overflow-auto">
                <li>此处省略<span class="text-blue-math">上帧画面 + 帧间向量表中的动态向量 = 一系列粗加工预测块</span>的步骤</li>
                <li>使用有限冲激响应插值滤镜 FIR filter 放大画面以便后面对齐</li>
                <li>将“粗加工预测块”与源视频所对应的画面使用 SATD 做差，得到当前的误差程度</li>
                <li>当前向量的 x，y 分量分别加减 ½，¼ 像素（插值放大的画面中是整数像素），即分别让这些块对比原画跑一遍 SATD：
                    <ul class="text-smaller">
                        <li><span class="text-blue-math">\(B\prime(x+½,y),B\prime(x,y+½),B\prime(x+½,y+½),B\prime(x+¼,y),B\prime(x,y+¼),B\prime(x+¼,y+¼),B\prime(x+¼,y+½),B\prime(x+½,y+¼)\)</span></li>
                    </ul>
                </li>
                <li>选出 SATD 误差值最小的块——中的 x,y 分量，纠正帧间向量表的动态矢量，完成补偿</li>
            </ol>
            <!-- } -->
            <p>关于 FIR 插值滤镜，以及 x264/5 分别用了哪些插值和搜索方法，见<a href="../../x265-web-tutorial/HTML/index.html#h2-6">x265 教程网页版 - 动态补偿</a>。</p>

            <code><b>--subme</b></code>
            <p class="font-monospace pl-5 m-0 overflow-auto">&lt;整数 1~10，推荐 6~10&gt;调整具体的动态补偿强度，x264 中同时决定模式决策和率失真优化的强度。根据画质和编码速度选择合适的参数值：</p>
            <ul class="font-monospace pl-5 text-smaller">
                <li><span class="text-blue-emph">1</span> 逐块 1/4 像素使用 SAD 算法检验一种对齐</li>
                <li><span class="text-blue-emph">2</span> 逐块 1/4 像素 SATD 算法检验两种对齐</li>
                <li><span class="text-blue-emph">3</span> 逐宏块 1/2 像素 SATD 一次，逐块 1/4 像素 SATD 一次</li>
                <li><span class="text-blue-emph">4</span> 逐宏块 1/4 像素 SATD 一次，逐块 1/4 像素 SATD 一次</li>
                <li><span class="text-blue-emph">5</span> 同时增加双向参考 B 块</li>
                <li><span class="text-blue-emph">6</span> 同时 I，P 帧启用率失真优化处理</li>
                <li><span class="text-blue-emph">7</span> 同时 I，P，B，b 帧启用率失真优化处理 </li>
                <li><span class="text-blue-emph">8</span> 同时 I，P 帧启用 <code>--rd-refine</code> 功能</li>
                <li><span class="text-blue-emph">9</span> 同时 I，P，B，b 帧启用 <code>--rd-refine</code> 功能</li>
                <li><span class="text-blue-emph">10</span> 使用 <code>--me hex</code> 动态搜索检验对齐，<span class="text-red-emph">需 <code>--trellis 2 --aq-strength &gt; 0</code></span></li>
                <li><span class="text-blue-emph">11</span> 关闭所有提前退出，边际效应过大，不推荐使用</li>
            </ul>
            <code><b class="text-red-emph">rd-refine</b></code>
            <p class="font-monospace pl-5 m-0 overflow-auto"> &lt;嵌入 <code>--subme 8</code> 中，x265 中可手动打开&gt; 率失真优化分析帧内预测的最佳量化和分块结果，耗时换压缩率和画质。x264 中还包括了最优动态向量的分析</p>

            <h2 id="h2-7">变换</h2>
            <div class="row">
                <p id="LR-UD-003" class="col-10">模拟信号转换为数字信号的主要步骤之一——将音量、亮度、温度、压力等信号整理为低频到高频的分量。具体来说，这个过程根据要处理的信号和用途不同，会使用傅里叶变换，小波变换，和 x264/5 使用的二维离散余弦变换 2D Discrete cosine transform。二维离散余弦变换利用预制的二维波形模具，通过穷举加减将源信号逐步分解成不同频率的平面波形，并合成变换块。<span class="text-gray-side">图：缩放到 8x8 的波形分布，由于 cos(x) 的波形范围是 -1~1，所以图中的黑色到白色并不是 0~255 或 16~235，而是 -1~1</span> </p>
                <img src="files/transform-quantization/DCT-Block.png" alt="image23" id="LR-UD-004" class="img-small img-right col-2 mb-auto" >
            </div>
            <p>变换的过程中，“DCT 像素”称为系子 coefficients。这些系子的强度可以是负值，表示反相的波形；也可以是小数，表示低强度的波形（但因为计算机浮点计算慢于整数计算，所以一般仅用于演示）。变换块左上角的系数是直流 DC 分量，代表整体亮度水平，其余的系数是交流 AC 分量，表示图像中的细节和纹理信息。</p>
            
            <button type="button" class="collapsible border-main rounded-3">点击展开/折叠内容：离散余弦变换的简化例子（内容有问题，临时放置于此，请忽略）</button>
            <div class="coll-content">
                <h3>离散余弦变换 DCT</h3>
                <p>每个频域分量都清点计算范围内所有像素值的“共鸣程度”，计为 DCT 频域系子的分量，得到变换块。</p>
                <p class="overflow-auto"><span class="text-blue-math">\[T(u,v) = \alpha(u) \alpha(v) \sum_{x=0}^{N-1} \sum_{y=0}^{N-1} f(x,y) \cos\left(\frac{(2x+1)u\pi}{2N}\right) \cos\left(\frac{(2y+1)v\pi}{2N}\right)\]</span></p>

                <h4>求和计算 Summation</h4>
                <p>上式的 <span class="text-blue-math">\(\sum_{x=0}^{N-1} \sum_{y=0}^{N-1}\)</span> 部分。等同于：</p>
                <div class="overflow-auto"><code class="text-blue-math">for($x=0; $x&lt;$N-1; $x++) { for($y=0; $y&lt;$N-1; $y++) { $T.u+=...; $T.v+=... } }</code></div>
                <p>因此，一个 2x2 块下，上式一共要计算 <span class="text-blue-math">(\2^2\)</span> 次，将每次的结果取和，在乘以归一化缩放值 <span class="text-blue-math">\( \alpha(u) \)</span> 和 <span class="text-blue-math">\( \alpha(v) \)</span> 完成变换。</p>
                
                <h4>均方根 Root Mean Square</h4>
                <p>RMS 是统计中常用的一种数据量化，用于表示一组数据平均值的平方根。对于一个包含 N 个值的数据集：<span class="text-blue-math">\( \{ x_1, x_2, \ldots, x_N \} \)</span> </p>
                <span class="text-blue-math overflow-auto">\[ \text{RMS} = \sqrt{\frac{1}{N} \sum_{i=1}^{N} x_i^2} \]</span>
                <p>具体到 DCT 变换，对于 N×N 块 <span class="text-blue-math">\( f(x,y) \)</span> 的均方根可以表示为：</p>
                <span class="text-blue-math overflow-auto">\[ \text{RMS}_{f(x,y)} = \sqrt{\frac{1}{N^2} \sum_{x=0}^{N-1} \sum_{y=0}^{N-1} f(x, y)^2} \]</span>
                <p>DCT 变换后，DCT 系子 <span class="text-blue-math">\( T(u,v) \)</span>的均方根为：</p>
                <span class="text-blue-math overflow-auto">\[ \text{RMS}_{\text{DCT}} = \sqrt{\sum_{u=0}^{N-1} \sum_{v=0}^{N-1} C(u, v)^2} \]</span>

                <h4>归一化 Normalize</h4>
                <p>保证变换后，块的能量不变，所以通过 <span class="text-blue-math">\( \alpha(u) \)</span> 和 <span class="text-blue-math">\( \alpha(v) \)</span> 两个缩放值来对齐，使得 <span class="text-blue-math">\( \text{RMS}_{\text{DCT}} = \text{RMS}_{f(x,y)} \)</span>：</p>
                <span class="text-blue-math">\[ \alpha(u), \alpha(v) = \begin{cases} \frac{1}{\sqrt{N}} & \text{if } u,v = 0 \text{ (DC)} \\ \frac{1}{\sqrt{2N}} & \text{if } u,v \neq 0 \text{ (AC)} \end{cases} \]</span>
                <p>而在 JPEG 中：</p>
                <div class="overflow-auto"><span class="text-blue-math">\[ \alpha(u), \alpha(v) = \begin{cases} \frac{1}{\sqrt{2}} \approx 0.7071 & \text{if } u,v = 0 \text{ (DC)} \\ 1 & \text{if } u,v \neq 0 \text{ (AC)} \end{cases} \]</span></div>

                <h4>一种变换 2x2 矩阵的例子</h4>
                <ol>
                    <li><b>输入：</b>一个 2x2 矩阵
                        <span class="text-blue-math">\[ C=\begin{bmatrix} 1 & 2 \\3 & 4 \end{bmatrix} \]</span>
                    </li>
                    <li><b>步骤 A1：</b>设定 DCT 系子
                        设立变量 <span class="text-blue-math">\(u\)</span>，<span class="text-blue-math">\(v\)</span>，代表 DCT 空间内的横向与纵向格子
                    </li>
                    <li><b>步骤 A2：</b>计算平均值（DC 分量）
                        <span class="text-blue-math">\[ DC = \frac{1}{4} \sum_{x=0}^{1} \sum_{y=0}^{1} f(x, y) = \frac{1}{4} \times (1 + 2 + 3 + 4) = 2.5 \]</span>
                    </li>
                    <li><b>步骤 A3：</b>计算 DCT 系数
                        <ol class="text-blue-math">
                            <li><b>\(C(0,0)\)</b>：
                                \[ C(0, 0) = \sum_{x=0}^{1} \sum_{y=0}^{1} f(x, y) \cos\left[\frac{(2x+1)0\pi}{4}\right] \cos\left[\frac{(2y+1)0\pi}{4}\right] - DC \]
                                \[ C(0, 0) = (1 \times \cos(0) \cos(0) + 2 \times \cos(0) \cos(0) + 3 \times \cos(0) \cos(0) + 4 \times \cos(0) \cos(0)) - 2.5 \]
                                \[ C(0, 0) = (1 + 2 + 3 + 4) - 2.5 = 7.5 - 2.5 = 5 \]
                            </li>
                            <li><b>\(C(0,1)\)</b>：
                                \[ C(0, 1) = \sum_{x=0}^{1} \sum_{y=0}^{1} f(x, y) \cos\left[\frac{(2x+1)0\pi}{4}\right] \cos\left[\frac{(2y+1)1\pi}{4}\right] \]
                                \[ C(0, 1) = 1 \times \cos(0) \cos(\pi/4) + 2 \times \cos(0) \cos(\pi/4) + 3 \times \cos(0) \cos(3\pi/4) + 4 \times \cos(0) \cos(3\pi/4) \]
                                \[ C(0, 1) = 1 \times \cos(0) \frac{\sqrt{2}}{2} + 2 \times \cos(0) \frac{\sqrt{2}}{2} + 3 \times \cos(0) \left(-\frac{\sqrt{2}}{2}\right) + 4 \times \cos(0) \left(-\frac{\sqrt{2}}{2}\right) \]
                                \[ C(0, 1) = (1 + 2 - 3 - 4) \frac{\sqrt{2}}{2} = -4 \frac{\sqrt{2}}{2} = -2\sqrt{2} \]
                            </li>
                            <li><b>\(C(1,0)\)</b>：
                                \[ C(1, 0) = \sum_{x=0}^{1} \sum_{y=0}^{1} f(x, y) \cos\left[\frac{(2x+1)1\pi}{4}\right] \cos\left[\frac{(2y+1)0\pi}{4}\right] \]
                                \[ C(1, 0) = 1 \times \cos(\pi/4) \cos(0) + 2 \times \cos(\pi/4) \cos(0) + 3 \times \cos(3\pi/4) \cos(0) + 4 \times \cos(3\pi/4) \cos(0) \]
                                \[ C(1, 0) = \frac{\sqrt{2}}{2} + \frac{\sqrt{2}}{2} - \frac{\sqrt{2}}{2} - \frac{\sqrt{2}}{2} = 0 \]
                            </li>
                            <li><b>\(C(1,1)\)</b>：
                                \[ C(1, 1) = \sum_{x=0}^{1} \sum_{y=0}^{1} f(x, y) \cos\left[\frac{(2x+1)1\pi}{4}\right] \cos\left[\frac{(2y+1)1\pi}{4}\right] \]
                                \[ C(1, 1) = 1 \times \cos(\pi/4) \cos(\pi/4) + 2 \times \cos(\pi/4) \cos(\pi/4) + 3 \times \cos(3\pi/4) \cos(3\pi/4) + 4 \times \cos(3\pi/4) \cos(3\pi/4) \]
                                \[ C(1, 1) = \frac{\sqrt{2}}{2} + \frac{\sqrt{2}}{2} + \frac{\sqrt{2}}{2} + \frac{\sqrt{2}}{2} = 2\sqrt{2} \]
                            </li>
                        </ol>
                    </li>
                    <li><b>结果 A：</b>得到的 DCT 系数矩阵为：
                        <span  class="text-blue-math"> \[ T = \begin{bmatrix} 5 & -2\sqrt{2} \\ 0 & 2\sqrt{2} \end{bmatrix} \] </span>
                    </li>
                </ol>

                <h4>类似 JPEG 计算 2x2 矩阵的例子</h4>
                <p>使用上述 JPEG 的缩放值对齐</p>
                <ol>
                    <li><b>输入：</b>一个 2x2 矩阵
                        <span class="text-blue-math">\[ C=\begin{bmatrix} 1 & 2 \\3 & 4 \end{bmatrix} \]</span>
                    </li>
                    <li><b>变换 B：</b>直接计算 DCT 系数
                        <ol class="text-blue-math">
                            <li><b>\(C(0,0)\)</b>：
                                \[ C(0,0) = \alpha(0) \alpha(0) \sum_{x=0}^{1} \sum_{y=0}^{1} f(x, y) \cos\left(\frac{(2x+1)0\pi}{4}\right) \cos\left(\frac{(2y+1)0\pi}{4}\right) \]
                                \[ C(0,0) = 0.7071 \times 0.7071 \times (1 + 2 + 3 + 4) = 5 \]
                            </li>
                            <li><b>\(C(0,1)\)</b>：
                                \[ C(0,1) = \alpha(0) \alpha(1) \sum_{x=0}^{1} \sum_{y=0}^{1} f(x, y) \cos\left(\frac{(2x+1)0\pi}{4}\right) \cos\left(\frac{(2y+1)1\pi}{4}\right) \]
                                \[ C(0,1) = 0.7071 \times 1 \times (1 \times 0.7071 + 2 \times -0.7071 + 3 \times 0.7071 + 4 \times -0.7071) = -1 \]
                            </li>
                            <li><b>\(C(1,0)\)</b>：
                                \[ C(1,0) = \alpha(1) \alpha(0) \sum_{x=0}^{1} \sum_{y=0}^{1} f(x, y) \cos\left(\frac{(2x+1)1\pi}{4}\right) \cos\left(\frac{(2y+1)0\pi}{4}\right) \]
                                \[ C(1,0) = 1 \times 0.7071 \times (1 \times 0.7071 + 2 \times 0.7071 + 3 \times -0.7071 + 4 \times -0.7071) = -2 \]
                            </li>
                            <li><b>\(C(1,1)\)</b>：
                                \[ C(1,1) = \alpha(1) \alpha(1) \sum_{x=0}^{1} \sum_{y=0}^{1} f(x, y) \cos\left(\frac{(2x+1)1\pi}{4}\right) \cos\left(\frac{(2y+1)1\pi}{4}\right) \]
                                \[ C(1,1) = 1 \times 1 \times (1 \times 0.5 - 2 \times 0.5 + 3 \times -0.5 + 4 \times 0.5) = -1 \]
                            </li>
                        </ol>
                    </li>
                    <li><b>输出 B：</b> 2x2 像素块的 DCT 系数矩阵
                        <span class="text-blue-math">\[ T = \begin{bmatrix} 5 & -1 \\ -2 & -1 \end{bmatrix} \]</span>
                    </li>
                </ol>
                <p>以上提供了两种变换，因为理论上只要能通过逆运算还原原来的 1-2-3-4 矩阵就算能用（当然量化矩阵也要跟着修改），且不同信号的编码可能会使用不同的变换算法。</p>
            </div>

            <h3>量化</h3>
            <p>简单地说，是根据不同的量化强度，块类型（亮度，色度，16x16，8x8，4x4）给出对应变换块的量化表/矩阵。将变换后的块点除量化矩阵，得到剩余 DCT 系子的块，从而减少高频的 DCT 系子分量，实现压缩。</p>
            <h4>量化值 qp</h4>
            <p>Quantization Parameter 是 CRF，ABR 等码率质量控制模式算出，以及率失真优化量化、模式决策等步骤所调整的中间变量</p>
            <h4>量化步长 qStep</h4>
            <p>Quantization Step-size 是 qp 于量化表中的映射值。规则是「qp 每 +1，则 qStep +0.125；qp 每 +6 则 qStep ×2，使其越往后增量越大」：</p>
            <div class="overflow-auto">
                <table class="table-center align-items-center text-smaller">
                    <tbody>
                        <tr class="border-lr">
                            <th class="px-1">qp</th>
                            <td class="px-1">0</td>
                            <td class="px-1">1</td>
                            <td class="px-1">2</td>
                            <td class="px-1">3</td>
                            <td class="px-1">4</td>
                            <td class="px-1">5</td>
                            <td class="px-1">6</td>
                            <td class="px-1">7</td>
                            <td class="px-1">8</td>
                            <td class="px-1">9</td>
                            <td class="px-1">10</td>
                            <td class="px-1">12</td>
                            <td class="px-1">14</td>
                            <td class="px-1">16</td>
                            <td class="px-1">18</td>
                            <td class="px-1">20</td>
                            <td class="px-1">22</td>
                            <td class="px-1">24</td>
                            <td class="px-1">26</td>
                            <td class="px-1">28</td>
                            <td class="px-1">30</td>
                            <td class="px-1">32</td>
                            <td class="px-1">34</td>
                            <td class="px-1">36</td>
                            <td class="px-1">38</td>
                            <td class="px-1">40…</td>
                        </tr>
                        <tr class="border-lr">
                            <th>qStep</th>
                            <td class="px-1">0.625</td>
                            <td class="px-1">0.6875</td>
                            <td class="px-1">0.8125</td>
                            <td class="px-1">0.875</td>
                            <td class="px-1">1</td>
                            <td class="px-1">1.125</td>
                            <td class="px-1">1.25</td>
                            <td class="px-1">1.375</td>
                            <td class="px-1">1.625</td>
                            <td class="px-1">1.75</td>
                            <td class="px-1">2</td>
                            <td class="px-1">2.5</td>
                            <td class="px-1">3.25</td>
                            <td class="px-1">4</td>
                            <td class="px-1">5</td>
                            <td class="px-1">6.5</td>
                            <td class="px-1">8</td>
                            <td class="px-1">10</td>
                            <td class="px-1">13</td>
                            <td class="px-1">16</td>
                            <td class="px-1">20</td>
                            <td class="px-1">26</td>
                            <td class="px-1">32</td>
                            <td class="px-1">40</td>
                            <td class="px-1">52</td>
                            <td class="px-1">64…</td>
                        </tr>
                    </tbody>
                </table>
            </div>

            <h4>矩阵 Matrix</h4>
            <p>一串于特定位置换行的数字，用括号括起来得到。矩阵和矩阵之间可以根据情况选一种算法实现加减乘除</p>

            <h4>矩阵间的点乘/内积 Dot Product</h4>
            <p>两个矩阵之间，位置相对应的数相乘，得到新的矩阵。如果两个矩阵大小不一，则需要设定其它规则才能计算。</p>
            <div class="overflow-auto"><span class="text-blue-math">\[ A = \begin{bmatrix} a_{1} & a_{2} \\ a_{3} & a_{4} \end{bmatrix}, \quad B = \begin{bmatrix} b_{1} & b_{2} \\ b_{3} & b_{4} \end{bmatrix}, \quad A \cdot B = \begin{bmatrix} a_{1} \cdot b_{1} + a_{2} \cdot b_{3} & a_{1} \cdot b_{2} + a_{2} \cdot b_{4} \\a_{3} \cdot b_{1} + a_{4} \cdot b_{3} & a_{3} \cdot b_{2} + a_{4} \cdot b_{4} \end{bmatrix} \]</span></div>

            <button type="button" class="collapsible border-main rounded-3">点击展开/折叠内容：矩阵间的行列式叉乘与外积</button>
            <div class="coll-content">
                <h4>矩阵间的行列式叉乘 Determinant cross product</h4>
                <p>通过一种算法（此处为行列式）将矩阵坍缩为一个数字（标量）得到。</p>
                <div class="overflow-auto"><span class="text-blue-math">\[ A = \begin{bmatrix} a_{1} & a_{2} \\ a_{3} & a_{4} \end{bmatrix}, \quad B = \begin{bmatrix} b_{1} & b_{2} \\ b_{3} & b_{4} \end{bmatrix} \]</span></div>
                <div class="overflow-auto"><span class="text-blue-math">\[ A \times B = (a_{1} \cdot a_{4} - a_{2} \cdot a_{3}) \cdot (b_{1} \cdot b_{4} - b_{2} \cdot b_{3}) \]</span></div>

                <h4>矩阵间的外积 - 克罗内克积 Outer product</h4>
                <p>将乘数矩阵本身乘进被乘数矩阵中的每一个值得到：</p>
                <div class="overflow-auto"><span class="text-blue-math">\[ A \otimes B = \begin{bmatrix} a_{1}B & a_{2}B \\ a_{3}B & a_{4}B \end{bmatrix} = \begin{bmatrix} a_{1}b_{1} & a_{1}b_{2} & a_{2}b_{1} & a_{2}b_{2} \\ a_{1}b_{3} & a_{1}b_{4} & a_{2}b_{3} & a_{2}b_{4} \\ a_{3}b_{1} & a_{3}b_{2} & a_{4}b_{1} & a_{4}b_{2} \\ a_{3}b_{3} & a_{3}b_{4} & a_{4}b_{3} & a_{4}b_{4} \end{bmatrix} \]</span></div>
            </div>

            <h4>矩阵间的哈达玛积 Haramad product</h4>
            <p>两个大小相同矩阵下的一种常用的自定义点乘/内积算法。</p>
            <div class="overflow-auto"><span class="text-blue-math">\[ A = \begin{bmatrix} a_{1} & a_{2} \\ a_{3} & a_{4} \end{bmatrix}, \quad B = \begin{bmatrix} b_{1} & b_{2} \\ b_{3} & b_{4} \end{bmatrix}, \quad A \circ B = \begin{bmatrix} a_{1} \cdot b_{1} & a_{2} \cdot b_{2} \\ a_{3} \cdot b_{3} & a_{4} \cdot b_{4} \end{bmatrix} \]</span></div>

            <p>x264 中，变换与量化会通过哈达玛积合并为一个矩阵表格，如 4x4 亮度块下为：</p>
            <div class="overflow-auto"><span class="text-blue-math">\[ \text{round} \begin{bmatrix}1/4 & 1/2\sqrt{10} & 1/4 & 1/2\sqrt{10} \\1/2\sqrt{10} & 1/10 & 1/2\sqrt{10} & 1/10 \\1/4 & 1/2\sqrt{10} & 1/4 & 1/2\sqrt{10} \\1/2\sqrt{10} & 1/10 & 1/2\sqrt{10} & 1/10 \end{bmatrix} \times Q_{Step} \times 2^6 \]</span></div>
            <p>得到 qp 为 0，1，2，4，5 下的 4x4 块变换量化合并矩阵分别为：</p>
            <div class="overflow-auto"><span class="text-blue-math">\[ \text{QP}_0 \rightarrow \begin{bmatrix} 10&13&10&13 \\ 13&16&13&16 \\ 10&13&10&13 \\ 13&16&13&16 \end{bmatrix}, \text{QP}_1 \rightarrow \begin{bmatrix} 11&14&11&14 \\ 14&18&14&18 \\ 11&14&11&14 \\ 14&18&14&18 \end{bmatrix}, \text{QP}_2 \rightarrow \begin{bmatrix} 13&16&13&16 \\ 16&20&16&20 \\ 13&16&13&16 \\ 16&20&16&20 \end{bmatrix}, \text{QP}_4 \rightarrow \begin{bmatrix} 16&20&16&20 \\ 20&25&20&25 \\ 16&20&16&20 \\ 20&25&20&25 \end{bmatrix}, \text{QP}_5 \rightarrow \begin{bmatrix} 18&23&18&23 \\ 23&29&23&29 \\ 18&23&18&23 \\ 23&29&23&29 \end{bmatrix} \]</span></div>

            <p>回到量化本身，如 JPEG 8x8 亮度变换块的量化，就是普通的矩阵除法：</p>
            <div class="overflow-auto"><span class="text-blue-math">\[ Q(u, v) = \text{round} \left( \frac{C(u, v)}{Q_m(u, v)} \right) \]</span></div>
            <div class="overflow-auto"><span class="text-blue-math">\[ \text{round} \left( {\begin{bmatrix} 515&65&-12&4&1&2&-8&5 \\ -16&3&2&0&0&-11&-2&3 \\ -12&6&11&-1&3&0&1&-2 \\ -8&3&-4&2&-2&-3&-5&-2 \\ 0&-2&7&-5&4&0&-1&-4 \\ 0&-3&-1&0&4&1&-1&0 \\ 3&-2&-3&3&3&-1&-1&3 \\ -2&5&-2&4&-2&2&-3&0 \end{bmatrix}}\div{ \begin{bmatrix} 16&11&10&16&24&40&51&61 \\ 12&12&14&19&26&58&60&55 \\ 14&13&16&24&40&57&69&56 \\ 14&17&22&29&51&87&80&62 \\ 18&22&37&56&68&109&103&77 \\ 24&35&55&64&81&104&113&92 \\ 49&64&78&87&103&121&120&101 \\ 72&92&95&98&112&100&103&99\end{bmatrix} } \right) = \begin{bmatrix} 32&6&-1&0&0&0&0&0 \\ -1&0&0&0&0&0&0&0 \\ -1&0&0&0&0&0&0&0 \\ -1&0&0&0&0&0&0&0 \\ 0&0&0&0&0&0&0&0 \\ 0&0&0&0&0&0&0&0 \\ 0&0&0&0&0&0&0&0 \\ 0&0&0&0&0&0&0&0 \end{bmatrix} \]</span></div>

            <p>x264 中，量化值 qp 大致上存在于以下几处：</p>
            <div class="overflow-auto">
                <table class="table-fit-container text-xs">
                    <thead>
                        <tr>
                            <th class="px-1">步骤</th>
                            <th class="px-1">名称</th>
                            <th class="px-1">应用</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr class="border-bottom">
                            <td class="px-1">率控制</td>
                            <td class="px-1">CRF/ABR</td>
                            <td class="px-1">逐帧 qp（或 cqp → 全局 qp）</td>
                        </tr>
                        <tr class="border-bottom">
                            <td class="px-1">I-P 帧质量比</td>
                            <td class="px-1">I-P Ratio</td>
                            <td class="px-1">P 帧 qp</td>
                        </tr>
                        <tr class="border-bottom">
                            <td class="px-1">P-B 帧质量比</td>
                            <td class="px-1">P-B Ratio</td>
                            <td class="px-1">B 帧 qp</td>
                        </tr>
                        <tr class="border-bottom">
                            <td class="px-1">自适应量化</td>
                            <td class="px-1">Adaptive Quantzation AQ</td>
                            <td class="px-1">逐块 qp</td>
                        </tr>
                        <tr class="border-bottom">
                            <td class="px-1">（率失真优化）模式决策</td>
                            <td class="px-1">Mode Decision MD</td>
                            <td class="px-1">逐块 qp</td>
                        </tr>
                        <tr class="border-bottom">
                            <td class="px-1">率失真优化量化</td>
                            <td class="px-1">Rate-distortion optimized quantization RDOQ</td>
                            <td class="px-1">逐块 qp</td>
                        </tr>
                        <tr>
                            <td class="px-1">色度块 qp 偏移</td>
                            <td class="px-1"><code>--chroma-qp-offset</code></td>
                            <td class="px-1">亮度与色度块 qp</td>
                        </tr>
                    </tbody>
                </table>
            </div>

            <h2 id="h2-8">率控制</h2>
            <h3>算出量化值</h3>
            <p>根据输入的质量设定参数，以及视频数据与人眼视觉的两种特性得到压缩强度——量化值 qp 的具体步骤。其中，视频数据已从时间域分为了关键帧与参考帧（预测帧 + 残差帧）。根据这一性质就可以推断基础的质量差异，如：</p>
            <code><b>--ipratio --pbratio</b></code>
            <p class="font-monospace pl-5 m-0 overflow-auto">&lt;浮点，默认 1.4、默认 1.3&gt;P 帧相比 IDR/i 帧，以及 B/b 帧相比 P 帧的质量偏移。默认预设是给录像视频片源用的。</p>
            <ul class="font-monospace pl-5 text-smaller">
                <li>低成本动漫/多静态画面/PPT 录屏画面：<span class="text-blue-emph">各降低 0.2</span></li>
                <li>剪辑素材：<span class="text-blue-emph">提高 --crf，不用改这两个参数</span></li>
                <li>YCbCr 4:4:4 片源：<span class="text-blue-emph">x264 默认会自动修改 --chroma-qp-offset，不用该这两个参数</span></li>
            </ul>
            <p>同时，“人眼视觉特性”代表人对明暗变化与画面细节程度的曲线感知。简单地说，就是人眼敏感于中低亮度的画面细节——需要非线性地根据亮度分配画面质量，以及画面细节损失的程度（量化压缩的强度）需要一个妥协平衡点——需要非线性地映射量化强度，共两个技术要求。具体的转换见 <a href="../../x265-web-tutorial/HTML/index.html#h2-11">x265 教程网页版 - 率控制</a>。</p>
            <p>其结果就是通过 CRF/ABR 通过非线性的推演，再转换出线性的 qp 值。一般分为 1~17，18~23，和 24~69 三个阶段，分配到 qp 1~17 的画面算作低量化，分配到 qp 18~23 的画面算作中量化，分配到 qp 24~69 的画面算作高量化。</p>
            <p>平面等本来就没有什么信息的分块就算经过高量化，也不会影响其画质；主要的损失出现在有无意地给内容复杂的纹理细节分块分配了高量化或降噪处理，导致了信息的损失。降噪处理影响画面细节的原因是噪点本身是突兀的像素值，所以只能用高频信息表示。</p>

            <h3>上层，下层与双层模式</h3>
            <ul>
                <li>任意上层模式可以搭配任意下层模式，得到双层模式</li>
                <li>上层模式本身不需要搭配下层模式</li>
                <li>只能同时使用一种上层或下层模式</li>
                <li>如果使用了双层模式，则不能使用任意上层或下层模式</li>
            </ul>
            <!-- x265 教程副本，更改需手动同步 { -->
            <h3>质量呼应码率 Constant Rate Factor CRF 上层模式</h3>
            <p>压制三角形下，距离妥协中心点最近的模式。因此也是压制最常用的模式。</p>
            <code><b>--crf</b></code>
            <p class="font-monospace pl-5 m-0 overflow-auto"> &lt;浮点范围 0~51，默认 23&gt;据 cplxBlur，cutree，B 帧偏移给每帧分配各自 qp 的固定目标质量模式，或简称质量呼应码率模式，统称 crf。素材级画质设在 16~18，收藏~高压画质设在 19~20.5，YouTube 是 23。由于动画和录像的内容差距，动画比录像要给低点</p>

            <h3>平均码率 Average Bitrate ABR 上层模式</h3>
            <p>编码器自行判断量化程度，尝试压缩到用户定义的平均码率 average bitrate 上，速度最快</p>
            <code><b>--bitrate</b></code>
            <p class="font-monospace pl-5 m-0 overflow-auto">&lt;整数 kbps&gt;平均码率。若视频易压缩且码率给高，就会得到码率比设定的片子；反过来低了会不照顾画质强行提高量化，使码率达标。如果给太低则会得到码率不达标，同时画质差的片子。平均码率模式，除 2pass 分隔，一般推流用的"码率选项"就是这个参数，速度快但同时妥协了压缩</p>
            <!-- } -->
            <h3>恒定量化值 Constant Quantizer Parameter CQP 双层模式</h3>
            <code><b>--qp</b></code>
            <p class="font-monospace pl-5 m-0 overflow-auto">&lt;整数 0~69，<span class="text-red-emph">禁用 CRF/ABR/模式决策/率失真优化</span>&gt; 设定全局量化强度。除非有既定目的，否则不建议</p>

            <!-- x265 教程副本，更改需手动同步 { -->
            <h3>2pass-ABR 双层模式</h3>
            <p>最简单模型下：先用 CRF 模式分析整个视频总结每帧的 qp 值，后根据 ABR 模式的码率限制统一分配量化值。有 pass 2 给特别高的平均码率，输出最小损失的最小体积近无损模式，以及 pass2 给码率硬限的全局整体压缩模式</p>
            <code><b>--pass 1</b></code>
            <p class="font-monospace pl-5 m-0 overflow-auto">&lt;挡位，导出 stats 数据文件&gt;</p>
            <code><b>--pass 2</b></code>
            <p class="font-monospace pl-5 m-0 overflow-auto">&lt;挡位，导入 stats 数据文件&gt;</p>
            <code><b>--stats</b></code>
            <p class="font-monospace pl-5 m-0 overflow-auto">&lt;路径，默认在 x264/5 所在目录下&gt; 设定导出和导入 stats 数据文件的路径和文件名</p>
            <!-- } -->

            <!-- x265 教程副本，更改需手动同步 { -->
            <h3>VBV 下层模式</h3>
            <p>说明见<a href="../../x265-web-tutorial/HTML/index.html#h2-8">x265 教程网页版</a></p>
            <code><b>--vbv-bufsize</b></code>
            <p class="font-monospace pl-5 m-0 overflow-auto">&lt;整数 kbps，默认关=0，<span class="text-red-emph">小于 maxrate</span>&gt; 编码器解出原画后，最多可占的缓存每秒。bufsize÷maxrate=播放时解码出每 gop 原画帧数的缓冲用时（秒）。<span class="text-blue-emph">值的大小相对于编完 GOP 平均大小。编码器用到是因为模式决策要解码出每个压缩步骤中的内容与原画作对比用</span>。</p>
            <code><b>--vbv-maxrate</b></code>
            <p class="font-monospace pl-5 m-0 overflow-auto">&lt;整数 kbps，默认关 0&gt; 峰值红线。用「出缓帧码率 - 入缓帧码率必≤maxrate"」限制编码器在 GOP 码率超 bufsize，即缓存跑满时压缩超载帧（提高 qp 值 + 强降噪至码率合规为止）。当入缓帧较小时，出缓帧就算超 maxrate 也会因缓存有空而不被压缩。所以有四种状态，需经验判断：</p>
            <ul class="font-monospace pl-5 text-smaller">
                <li>大：GOP 大小=bufsize=2×maxrate，超限后等缓存满再压，避开多数涨落，适合限平均率的串流</li>
                <li>小：GOP 大小=bufsize=1×maxrate，超码率限制后直接压，避开部分涨落，适合限峰值的串流</li>
                <li>超：GOP 大小&lt;bufsize=1~2×maxrate，超码率限制后直接压，但因视频小/crf 大所以没啥作用</li>
                <li>欠：GOP 大小&gt;bufsize=1~2×maxrate，超码率限制后直接压，但因视频大/crf 小所以全都糊掉</li>
            </ul>
            <p class="font-monospace pl-5 m-0 overflow-auto">由于 gop 多样，4 种状态可以出现在同一视频中。buf/max 实际控制了这些状态的出现概率</p>
            <!-- } -->
            <code><b>--ratetol</b></code>
            <p class="font-monospace pl-5 m-0 overflow-auto">&lt;浮点百分比，默认 1&gt; maxrate 限码的容错程度，用于防止压缩过大，但与此同时码率过大所导致卡顿的次数会增加</p>
            <!-- x265 教程副本，更改需手动同步 { -->
            <h3>FTQP 下层模式</h3>
            <p>手动通过文件制定帧类型和 qp 值。</p>
            <code><b>--qpfile</b></code>
            <p class="font-monospace pl-5 m-0 overflow-auto">&lt;路径到文件&gt;手动指定帧类型和 qp 值 closed-gop 下 K 帧的 frame type qp 下层模式。qpfile 文件内的格式为"帧号 帧类型 QP"</p>
            <ul class="font-monospace pl-5 text-smaller">
                <li>帧类型可以选 [I,i,K,P,B,b]</li>
                <li>大写 B 代表 B-Pyramid</li>
                <li>大写 I 代表 IDR 帧</li>
                <li>K 在 <code>--no-open-gop</code> 时代表 IDR 帧</li>
                <li>K 在  <code>--open-gop</code> 时代表 i 帧</li>
                <li>x265 中，QP 值可以不填，代表使用上层率控制模式</li>
                <li>x264 中，QP 值填<span class="text-blue-emph">-1</span> 代表使用上层率控制模式</li>
            </ul>
            <p class="font-monospace pl-5 m-0 overflow-auto">qpfile 例：</p>
            <ul class="font-monospace pl-5 text-smaller list-dotless">
                <li>0 I 18</li>
                <li>1 P 20</li>
                <li>2 B 22</li>
                <li>3 i 21</li>
                <li>4 b 18</li>
            </ul>
            <!-- } -->
            <h3>其它率控制功能</h3>
            <p>可以搭配除 CQP 以外的上下层模式使用。</p>
            <code><b>--qpmin</b></code>
            <p class="font-monospace pl-5 m-0 overflow-auto">&lt;整数 0~51&gt;由于画质和优质参考帧呈正比，所以仅高压环境建议设最高 14。</p>
            <code><b>--qpmax</b></code>
            <p class="font-monospace pl-5 m-0 overflow-auto">&lt;整数 0~51&gt;在要用到颜色键，颜色替换等需要清晰物件边缘的滤镜时，可以设<span class="text-blue-emph">26</span>防止录屏时物件的边缘被压缩的太厉害，其他情况永远不如关 <code>--cutree/--mbtree</code></p>
            <code><b>--chroma-qp-offset</b></code>
            <p class="font-monospace pl-5 m-0 overflow-auto">&lt;整数，默认 0&gt;AVC 规定 CbCr 的码率之和应等于 Y 平面，所以 x264 会拉高色度平面的量化。</p>
            <ul class="font-monospace pl-5 text-smaller">
                <li>使用 <code>--psy-rd</code> 后，x264 会自动设定 <span class="text-blue-emph">-2~-4</span>。</li>
                <li>不用 <code>--psy-rd</code> 时，动漫或幻灯片录屏片源的 4:2:0 视频可手动设 <span class="text-blue-emph">-2~-4</span></li>
                <li>编码 YCbCr 4:4:4 时，x264 会自动设定 <span class="text-blue-emph">-2~-4</span>。</li>
            </ul>
            <code><b>--deadzone-inter</b></code>
            <p class="font-monospace pl-5 m-0 overflow-auto">&lt;整数 0~32，默认 21，<code>--trellis</code> 小于 2 时开启&gt;一种逻辑简单的帧间再量化——细节面积小于死区就删掉，大就保留。一般用途建议 8，高画质建议 6</p>
            <code><b>--deadzone-intra</b></code>
            <p class="font-monospace pl-5 m-0 overflow-auto">&lt;整数，范围 0~32，默认 11，--trellis=2 时无效，小于 2 自动开启&gt;一种逻辑简单的帧间再量化——细节面积小于死区就删掉，大就保留。一般用途建议 8，高画质建议 4</p>

            <h4>分段压制控制</h4>
            <p>手动指定帧数片段，每个片段允许指定一种上层模式和一些控制参数。</p>
            <code><b>--zones</b></code>
            <p class="font-monospace pl-5 m-0 overflow-auto">&lt;开始帧，结束帧，参数 A，参数 B…&gt; 手动在视频中划区，采用不同上层模式来实现如提高压制速度，节省平均码率，提高特定画面码率等用途 (一般用来"处理"片尾滚动字幕). zones 内的 me, merange 强度/大小不能超 zones 外。可用参数有 b=, q=, crf=, ref=, scenecut=, deblock=, psy-rd=, deadzone-intra=, deadzone-inter=, direct=, me=, merange=, subme=, trellis=</p>
            <ol class="font-monospace pl-5 text-smaller">
                <li>参数 b= 调整码率比率，限制 <code>--zones</code> 内的场景使用当前 0~99999% 的码率，100% 相当于不变</li>
                <li>参数 q= 即 CQP 模式的 <code>--qp</code> 参数</li>
            </ol>

            <h3>率控制模式的选择</h3>
            <p>一般情况下，用户要求在可接受的编码速度（fps 为单位）下，得到画质较高、文件体积较小的视频，构成了压制三角形。而不同的率控制模式，包括不同的视频编码器都会影响这一点。注意妥协点有三种：不省时，码率大，画质差，对应了三种不同的编码策略。</p>
            <div class="align-items-center">
                <img src="files/rate-control/rate-control-mode-selection.png" alt="image24" class="img-medium">
                <p class="text-gray-side">图：不同率控制模式权衡编码速度，画质，文件体积的能力不同，当然有的模式根本没得选</p>
            </div>
            <ul>
                <li>同时追求以上三点：选择距离妥协中心点最近的模式/编码器</li>
                <li></li>
                <li>只追求以上两点，且不希望彻底妥协第三点：选择距离妥协中心点近的模式/编码器，并通过限制来偏移结果到追求的两点
                    <ul>
                        <li>例如使用 CRF 模式，搭配 VBV 来保证视频串流足够流畅的策略</li>
                    </ul>
                </li>
                <li>CPU 性能或散热受限：选择距离妥协中心点远的模式/编码器
                    <ul>
                        <li>例如手机录像、NVENC，SVT 编码器只能同时追求省时加清晰，省时加低码，且由于编码功能相比软件编码残缺，所以做不到清晰加低码</li>
                        <li>一般情况下，显卡或核显的主要功能是负责视频解码，适合用于多条视频轨的剪辑工作，硬件编码器则是在 CPU 被游戏等高负载工作占用时替代它进行录屏用的</li>
                        <li>CPU 算力被游戏等进程占用后，只要硬盘和内存带宽足够，可以用高码率 ABR 设定来节省算力负载</li>
                    </ul>
                </li>
            </ul>

            <h2 id="h2-9">自适应量化</h2>
            <p>CRF/ABR 设定每帧量化值 qp 后，方差自适应量化 Variance adaptive quantizer VAQ 会将每帧的 qp 细化到块上。AQ 与 VAQ 存在混淆。方差 variance 代表差→方→和→均的计算顺序。将数据样本逐个与整体平均做差，以偏差之和窥数据之衡。乘方是方便正负数一起求和计算（算式左的σ也乘方，优化了正负号在二进制中的额外占用）：</p>

            <h3>方差 Variance</h3>
            <p>方差表示数据样本相对于整体平均值的离散程度，通过差→方→和→均的计算顺序，以偏差之和窥数据之衡。计算如下：</p>
            <span class="text-blue-math">\[ \sigma^{2}=\frac{\sum_{i=1}^{N} (x_{i}-\overline{x})^{2}}{N} \]</span>
            <ol>
                <li>每个数据样本减去整体平均值，得到差值</li>
                <li>差值进行平方以放大误差，并消除负值差距的影响</li>
                <li>平方后的值求和，得到总平方误差</li>
                <li>总平方误差除以样本数得到方差</li>
            </ol>
            <div class="overflow-auto"><span class="text-blue-math">\[ \text{Variance} = \frac{\text{SSE}_{Pixels_{Macroblock}} - (\text{SAD}_{Macroblock})^2}{Pixels_{Macroblock}} = \frac{\text{SSE}_{Pixels_{Macroblock}} - (\text{SAD}_{Macroblock})^2}{256} \]</span></div>
            

            <h4>自适应量化与方差自适应量化的区别：</h4>
            <ul>
                <li><b>AQ</b>：降低复杂区域的 qp 值，提高平面区域的 qp 值</li>
                <li><b>VAQ</b>：使用方差，将 AQ 的判断的逻辑去线性化</li>
            </ul>

            <code><b>--aq-mode</b></code>
            <p class="font-monospace pl-5 m-0 overflow-auto">&lt;整数 0~3&gt;据原画和 CRF/ABR 强度设定，码率不足时分配细分块 qp 值的策略</p>
            <ul class="font-monospace pl-5 text-smaller">
                <li><span class="text-blue-emph">1</span>普通自适应量化，适用于简单平面以及快速编码场景</li>
                <li><span class="text-blue-emph">2</span>方差自适应量化，同时自动调整 <code>--aq-strength</code> 的强度。推荐用于录像电影，或搭配 CRF 小于 17，高码率 ABR 等不会欠码的策略</li>
                <li><span class="text-blue-emph">3</span>在欠码时倾向保暗场画质</li>
                <li><span class="text-blue-emph">4</span>在欠码时更加倾向保纹理画质（接受平面涂抹失真，动漫和幻灯片录屏场景慎用）</li>
            </ul>
            <code><b>--aq-strength</b></code>
            <p class="font-monospace pl-5 m-0 overflow-auto">&lt;浮点&gt;自适应量化强度，推荐搭配 <code>--aq-mode</code> 使用。如动漫和幻灯片录屏等平面多过纹理的场景下 <code>--aq-mode <span class="text-blue-emph">1</span> --aq-strength <span class="text-blue-emph">0.8</span></code>, <span class="text-blue-emph">2</span>:<span class="text-blue-emph">0.9</span>，<span class="text-blue-emph">3</span>:<span class="text-blue-emph">0.7</span></p>
            <ul class="font-monospace pl-5 text-smaller">
                <li>录像或更复杂上如果不愿降低 CRF/增加 ABR 码率，则额外增加 <span class="text-blue-emph">0.1~0.2</span></li>
                <li>注意低成本动漫和幻灯片录屏等平面多过纹理的画面，因此码率不足时反而要更改 qp 分配策略为妥协纹理</li>
            </ul>
           
            <h2 id="h2-10">环路滤波</h2>
            <p>由于 AVC 的环路滤波步骤中只有去块，所以叫去块滤波在此更准确。</p>
            <!-- x264 教程副本，更改需手动同步 { -->
            <h3>去块滤镜</h3>
            <p>修复“CRF/ABR 模式在某些场景的部分区域里分配量化值过高时，宏块间出现明显横纵割痕瑕疵”的平滑滤镜。编码器内去块利用了帧内帧间搜索到的信息，而理论上相比外部滤镜误判更少（当然外部滤镜也能做动态和帧内搜索）。去块大体上是检查 1 像素宽，且此块边缘没有较大像素值变化造成的横纵边缘（所以也存在误判）。块失真源自块间不统一的量化程度，有的块量化高流就会从邻近画面里凸现出来。而去块手段是平滑滤镜，因此要降低强度才适用于高码视频，动漫，素材录屏等锐利画面。边界强度 Boundary strength（去块力度判断）</p>
            <div class="align-items-center">
                <img src="files/deblocking/Deblock-detection-visualization.png" alt="image25" class="img-medium" >
                <img src="files/deblocking/Deblock-edge-visualization.png" alt="image26" class="img-medium" >
                <p class="text-gray-side">图：取最小 8x8 范围（两个 4x4 分块）间的界线举例。</p>
            </div>

            <ul class="text-smaller">
                <li>平滑 4：a 与 1 皆为帧内块，且边界位于 CTU/宏块间，最强滤镜值</li>
                <li>平滑 3：a 或 1 皆为帧内块，但边界不在 CTU/宏块间</li>
                <li>平滑 2：a 与 1 皆非帧内块，含一参考源/已编码系子</li>
                <li>平滑 1：a 与 1 皆非帧内块，皆无参考源/已编码系子，溯异帧或动态向量相异</li>
                <li>平滑 0：a 与 1 皆非帧内块，皆无参考源/已编码系子，溯同帧或动态向量相同，滤镜关</li>
            </ul>

            <code><b>--deblock</b></code>
            <p class="font-monospace pl-5 m-0 overflow-auto"> &lt;浮点偏移值，默认 1:0。推荐 0:0，-1:-1，-2:-1&gt; 平滑强度：搜索精度。两值于原有强度上增减。</p>
            <ul class="font-monospace pl-5 text-smaller">
                <li>平滑<span class="text-blue-emph">≥1</span>时用以压缩</li>
                <li>平滑<span class="text-blue-emph">-2~-1</span>时略降锐度，适合串流</li>
                <li>平滑<span class="text-blue-emph">2</span>适合锐利视频源，4k 电影，游戏录屏。提高码率且会出现块失真</li>
                <li>平滑<span class="text-blue-emph">-3~-2</span>适合高码动画源/桌面录屏。增块失真，但观感仍比 1 好</li>
                <li>搜索<span class="text-blue-emph">大于 2</span>易误判；<span class="text-blue-emph">小于 1</span>会遗漏。建议保持<span class="text-blue-emph">0~-1</span>，除非 qp 大于 26 时设设<span class="text-blue-emph">1</span></li>
            </ul>
            <!-- } -->

            <h2 id="h2-11">模式决策</h2>
            <ol>
                <li><b>整合动态搜索与补偿可能性</b>：
                    <ul>
                        <li>计算并收集每种帧内，帧间预测模式的率失真分数（于下文解释）</li>
                    </ul>
                </li>
                <li><b>整合分块参考量化可能性</b>：
                    <ul>
                        <li>计算并收集每种细分块方案（4x4，8x8，16x16），参考帧长度，量化强度下的率失真分数</li>
                    </ul>
                </li>
                <li><b>压缩方案的定制</b>：
                    <ul>
                        <li>选择码率最小的压缩方案并不是最优解，因此找出率失真分数最高的方案集，得到码率与画质最为平衡的方案</li>
                    </ul>
                </li>
            </ol>
            <p class="text-gray-side">注：如果片源已有明显的边缘失真，模式决策优化反而需要减少，因为优化方向是尽可能保留原画，导致失真本身被当成细节</p>

            <h2 id="h2-12">优化策略</h2>
            <!-- x264 教程副本，更改需手动同步 { -->
            <h3>率失真优化</h3>
            <p>Rate distortion optimization，RDO。原本有损压缩视频编码器的策略就是码率越小越好——所以量化强度越大越好。但实际情况是量化压缩相当程度的破坏了 P-B 帧原本可以参考 I 帧的部分——因为量化后差异太大而只能放弃参考，换成 I 块。解决这种乱量化问题的方法是将失真，码率分别看成两种越大越差的程度；将其中一个程度乘以一个缩放值以对齐另一个（使两值权重对等）以相互牵制出平衡点。再将这个“新的程度”应用到原本的编码器策略里，就是率失真优化。</p>
            <p>“编码器策略”就是模式决策。率失真程度由代价函数「开销=失真+λ⋅码率」（越小越好）得出：</p>
            <span class="text-blue-math">\[J = D + \lambda \cdot R\]</span>
            <p>由于这个式子是一元一次函数（ <span class="text-blue-math">\(y = mx + b\)</span> ），所以可画图表示为每个方案 J 作为位于 D，R 坐标系，斜度 λ 线上的点；其中失真 D 用平方差 SSE 或总差异 SAD 判断（SSE 多取一步平方，使较大的差异呈指数增长）进而分到更多补偿的码率。拉格朗日值 λ 源于 qp，即 crf，abr 指定的率失真斜度区间。qp 越大斜度越小：</p>
            <ul>
                <li><span class="text-blue-math">\(\lambda=0\)</span>则无斜度，则代价等于失真——码率变而画质不变，宜压缩。</li>
                <li><span class="text-blue-math">\(\lambda \rightarrow 0\)</span>（趋 0）则开销趋失真——适当压缩就不会影响画质</li>
                <li><span class="text-blue-math">\(\lambda &gt; 0\)</span>则开销大于失真——保画质收益大于压缩收益，应该保画质</li>
            </ul>
            <div class="align-items-center">
                <img src="files/rate-distorsion-optimization/x264-JM-RDO-Lambda.png" alt="image27" class="img-medium" >
                <img src="files/rate-distorsion-optimization/RDO-Lambda-Slopes.png" alt="image28" class="img-medium" >
                <p class="text-gray-side">图：率失真优化中λ的斜度变化与效果</p>
                <img src="files/rate-distorsion-optimization/RDO-qStep-Chart.png" alt="image29" class="img-medium" >
                <p class="text-gray-side">图：率 - 失真表格中不断调整并得到“×”的实际效果</p>
            </div>
            <!-- } -->
            <code><b>--fgo</b></code>
            <p class="font-monospace pl-5 m-0 overflow-auto">&lt;整数默认关，推荐 15 左右&gt;将高频信号在量化前后的差距也算进率失真优化的统计中，使优化更倾向于保留细节和噪声</p>

            <h3>心理视觉优化</h3>
            <p>Psycho-visual optimization PVO 更类似于一种自适应量化，利用人类视觉系统的特性，通过掩蔽和感知量化量化，实现低码画面的码率再分配，保持高压缩的同时，提供更好的主观视觉质量。主观质量是建立在损失客观质量（与输入源的差距）上的质量。</p>
            <ol>
                <li><b>空间掩蔽 Spatial Masking</b>：
                    <ul>
                        <li>人眼会忽略高锐度边缘周边区域的画面，因此增加这些区域的 qp</li>
                    </ul>
                </li>
                <li><b>频域掩蔽 Frequency Masking</b>：
                    <ul>
                        <li>人眼会忽略高频细节区域内的低频信号分量，因此可以在变换块中剔除高频块的低频分量</li>
                    </ul>
                </li>
            </ol>
            <code><b>--psy-rd</b></code>
            <p class="font-monospace pl-5 m-0 overflow-auto">&lt;a:b 浮点，默认 1:0&gt;心理学优化设置。a 保留纹理，b 在 a 的基础上保留噪点细节，ab 值据画面复杂度拉高，</p>
            <ul class="font-monospace pl-5 text-smaller">
                <li>低成本动漫与幻灯片录屏画面：<span class="text-blue-emph">0.4:0.1</span>~<span class="text-blue-emph">0.6:0.15</span></li>
                <li>电影，录像等场景：<span class="text-blue-emph">0.7:0.12</span>~<span class="text-blue-emph">1.3:0.2</span></li>
                <li><code>--no-mbtree</code> 可将 b 设置为 <span class="text-blue-emph">0</span></li>
            </ul>
            <code><b>--no-psy</b></code>
            <p class="font-monospace pl-5 m-0 overflow-auto">&lt;开关&gt;若视频量化很低，纹理清楚，没有优化的必要可以关。但大部分情况下不应该关，而是用较低的优化强度</p>
            <div class="align-items-center">
                <img src="files/rate-distorsion-optimization//Principle-on-Image-Quality.png" alt="image30" class="img-small" >
                <p class="text-gray-side">图：心理视觉优化保留高频信号，同时压缩周围和其中的非高频信号</p>
            </div>

            <h3>宏块树与量化值曲线缩放 qComp</h3>
            <p>源自 libavcodec 以复杂动态场景的帧间参考少而应提高压缩，分码率给参考多而远的简单动态场景，以实现同码率下整体画质更高结果的逻辑。缺点则是动漫场景等「背景不动前景动」的场景被误压缩。说到底是处理精度低而非错误，应逐宏块应用这套逻辑，<a href="https://web.archive.org/web/20150224032942/http:/x264dev.multimedia.cx/archives/98">就有了 mbtree</a>。量化值曲线缩放 quantizer curve compression 则被贬为控制 mbtree 等一系列 qp 分配算法中的一个缩放参数，见 <a href="https://www.desmos.com/calculator/aa7rsjuxkr">desmos 互动例</a>。</p>
            <h4>量化值曲线缩放的用途</h4>
            <ol class="overflow-auto">
                <li>（仅 ABR 模式）根据宏块的数量与 <code>--qcomp</code> 值设置初始复杂度百分比：
                    <span class="text-blue-math">\[ \text{Complexity} = \left( \frac{\text{Count}_{MB}}{2} \right) ×700000^{\left( \frac{qcomp}{100} \right)} \div 100 \]</span>
                </li>
                <li>获取当前场景的长度 <span class="text-blue-math">\( \text{Duration}_{clip} \)</span></li>
                <li>当前帧与下一帧间的图像模糊后做 SATD，获得「模糊复杂度 <span class="text-blue-math">\( \text{Complexity}_{blurred} \)</span>」</li>
            </ol>
            <ul class="overflow-auto">
                <li>（关 mbtree 时）使用 <code>--qcomp</code> 缩放模糊复杂度，以换算出当前帧的 qScale：
                    <span class="text-blue-math">\[ \text{qScale} = \left( \text{Complexity}_{blurred} \right)^{1-qcomp} \]</span>
                </li>
                <li>（开 mbtree 时）据 I 帧在当前片段的权重设单帧 qp（基准单帧用时 ÷ 当前场景用时 × I 帧用时 ÷ 帧率）：
                    <span class="text-blue-math">\[ \text{qScale} = Duration_{frame} \div Duration_{clip}\times Duration_{iframe} \div \text{fps} \]</span>
                </li>
            </ul>
            <code><b>--qcomp</b></code>
            <p class="font-monospace pl-5 m-0 overflow-auto"> &lt;浮点范围 0.5~1，推荐默认 0.6&gt;模糊复杂度 cplxBlur 以及 mbtree 迭代每帧 qp 值范围的曲线抑制参数。越小则复杂度迭代越符合实际状况，抑制 CRF，mb-cutree，bframes 影响的效果就越弱，搭配高 CRF 能使码率控制接近 VBV 的程度。越大则 CRF，mb-cutree，bframes 越没用，越接近 CQP</p>
            <ul class="font-monospace pl-5 text-smaller">
                <li><span class="text-blue-emph">小于 0.5，中~强 mbtree</span> CRF/ABR低延迟逐帧迭代qp; 画面主前景动时用，允许 mbtree 导致零星宏块欠码</li>
                <li><span class="text-blue-emph">0.5~0.7 中 mbtree</span> CRF/ABR中延迟逐帧迭代qp, 画面含背景动，或混合情况用，平衡优先</li>
                <li><span class="text-blue-emph">大于 0.7 中~弱 mbtree</span> CRF, ABR 中~高延迟逐帧迭代 qp, 保留重噪点，或 FPS/STG 游戏录屏场景用</li>
                <li><span class="text-blue-emph">小于 0.5 关 mbtree</span> 画面不分前背景，如静态图像，PPT/桌面录屏节约性能用</li>
                <li><span class="text-blue-emph">大于 0.5 关 mbtree</span> 动态画面，不分前背景时节约性能用</li>
                <li><span class="text-blue-emph">0</span>（if 判定）启用固定码率模式</li>
                <li><span class="text-blue-emph">1</span>（if 判定）启用固定 qp 模式</li>
            </ul>

            <h4>宏块树 Macroblock-Tree</h4>
            <p>如果一个宏块用作帧间参考的码率比用作帧内参考低 70%，则该宏块可视为 30% 非帧间参考和 70% 帧间参考两部分。已知帧间参考占据的部分越多，则这个宏块自身就没有多少信息；而在宏块树所运行的时间，这个宏块是位于软转场 GOP 末尾——scenecut 步骤之后，keyint 步骤之前。因此，可以增强其压缩——把更多的码率分给参考传播最远的 I 帧，以提拔整个软转场 GOP 的画质。详见 <a href="http://lazybing.github.io/blog/2021/06/22/h264-rate-control-algorithm/">x264 率控制算法</a> 及 <a href="https://huyunf.github.io/blogs/2017/12/06/x264_slice_type_decision/MBtree paper.pdf">mbtree paper</a>。</p>
            <p>由于宏块树的步骤位于前瞻进程 Lookahead 中，而前瞻进程位于动态搜索和运动补偿之前，且 Lookahead 只使用半分辨率的视频帧，因此，此时的宏块树只能额外尝试简单的帧内和帧间预测。</p>
            <ul>
                <li>注：帧间参考代价只能小于等于帧内参考代价，类似于（同视频下的）P 帧体积不应大于 I 帧
                    <ul class="text-smaller">
                        <li>若出现帧间参考代价大于帧内参考代价的情况，就重设为「帧间参考代价等于帧内参考代价」</li>
                    </ul>
                </li>
            </ul>
            <p>宏块帧内和帧间的参考代价记为 <span class="text-blue-math">\(\text{Cost}_{intra}\)</span> 和 <span class="text-blue-math">\(\text{Cost}_{inter}\)</span>，通过 Lookahead 中以下“搜索”步骤得到：</p>
            <ul>
                <li><b>简单帧内预测/宏块自身信息量预测：</b>尝试水平和垂直模式
                    <ul class="text-smaller">
                        <li>水平模式：得到残差为 2，代价为 4</li>
                        <li>垂直模式：得到残差为 3，代价为 5</li>
                        <li>选择水平模式，记 <span class="text-blue-math">\(\text{Cost}_{intra}\)</span> 代价为 4</li>
                    </ul>
                </li>
                <li><b>简单帧间预测/宏块参考信息量预测：</b>以上一帧为参考，进行运动估计
                    <ul class="text-smaller">
                        <li>运动矢量 (1,1)：得到残差为 1，代价为 2</li>
                        <li>运动矢量 (2,2)：得到残差为 2，代价为 3</li>
                        <li>选择运动矢量 (1,1)，记 <span class="text-blue-math">\(\text{Cost}_{inter}\)</span> 代价为 2</li>
                    </ul>
                </li>
                <li><b>宏块总代价：</b>自身代价 + 上一帧帧间预测代价 <span class="text-blue-math">\( \text{Cost}_{intra} + \text{Cost}_{inter} \)</span>
                    <ul class="text-smaller">
                        <li><b>上一帧帧间预测代价：</b>上一帧的宏块与当前帧宏块匹配帧间预测模式所得的代价</li>
                    </ul>
                </li>
                <li><b>溯块总代价：</b>自身代价 + 下一帧帧间预测代价 <span class="text-blue-math">\( \text{Cost}_{intra} + \text{Cost}_{propagate} \)</span>
                    <ul class="text-smaller">
                        <li><b>下一帧帧间预测代价：</b>下一帧的宏块与当前帧宏块匹配帧间预测模式所得的代价 + <span class="text-blue-math">\(\text{Propagate}_{amount}\)</span> 累积的代价</li>
                        <li>由于 B 帧是双向参考帧，所以不存在「上/下一帧帧间预测代价」，而是「参考帧/被参考帧间预测代价」</li>
                    </ul>
                </li>
            </ul>
            <ol>
                <li><b>设定：</b>各个宏块自身代价与参考代价的比率，再从 100% 减掉这个比率，得到给其他宏块参考的信息比率
                    <span class="text-blue-math"> \[ \text{propagate}_{fraction}=1-\left(\frac{\text{Cost}_{intra}}{\text{Cost}_{inter}}\right) \]</span>
                </li>
                <li><b>设定：</b>各个宏块传播到下游宏块的代价量 = 给其他宏块参考的信息比率 × 溯块总代价
                    <span class="text-blue-math"> \[ \text{Propagate}_{amount} = \text{Propagate}_{fraction} \times (\text{Cost}_{intra} + \text{Cost}_{propagate}) \]</span>
                    <ul class="text-smaller">
                        <li><span class="text-blue-math">\( \text{Propagate}_{fraction} \)</span> 越小，传播到下游宏块的信息量就越少</li>
                        <li><span class="text-blue-math">\( \text{Cost}_{intra} + \text{Cost}_{propagate} \)</span> 越大，传播到下游宏块的信息量就越大</li>
                    </ul>
                </li>
                <li><b>计算：</b>从最远范围 <code>--rc-lookahead</code> 开始，从远到近地累积所有宏块的 <span class="text-blue-math">\( \text{Propagate}_{amount} \)</span>，作为统计列表中下一个宏块的 <span class="text-blue-math">\( \text{Cost}_{propagate} \)</span>
                    <ul class="text-smaller">
                        <li>这里非常绕，总之就是「传播到下游宏块的信息量 <span class="text-blue-math">\( \text{Propagate}_{amount} \)</span>」是持续更新累积的过程，而不是从当前帧往后查找传播了多少信息</li>
                        <li>如果出现动态位移（当前宏块的范围被切分到下帧的 4 个宏块之间时），这 4 个宏块会各自按比例拆分出各自的传播信息量</li>
                    </ul>
                </li>
                <li><b>分配：</b>从最远范围 <code>--rc-lookahead</code> 开始，从远到近地根据已有的 <span class="text-blue-math">\( \text{Cost}_{propagate} \)</span> 和自身的信息量 <span class="text-blue-math">\( \text{Cost}_{intra} \)</span>，通过 <span class="text-blue-math">\( \log_{2}() \)</span> 非线性地映射到 qp，得到宏块树中每个宏块的量化值偏移：
                    <span class="text-blue-math"> \[ \Delta \text{QP} = -\text{strength} \times \log_{2}\left( \frac{\text{Cost}_{intra}}{\text{Cost}_{propagate}} \right) \div \text{Cost}_{intra} \]</span>
                </li>
            </ol>
            <p class="text-gray-side">大部分情况下 mbtree 偏移值为零，因为宏块没有溯块信息可用</p>
            <!-- x265 教程副本，需要手动同步更改 { -->
            <code><b>--rc-lookahead</b></code>
            <p class="font-monospace pl-5 m-0 overflow-auto">&lt;帧数量，范围 1~250，推荐 keyint÷2&gt; 指定 cutree 的检索帧数，通常设在帧率的 2.5~3 倍。高则占用内存增加延迟，低则降低压缩率和平均画质。</p>
            <p class="text-gray-side pl-5 m-0 overflow-auto">注：mbtree/cutree 会自动选择 <code>--rc-lookahead</code> 和 <span class="text-blue-math text-smaller">\( \max\left( \text{keyint}, \max\left( \text{vbv-maxrate}, \text{bitrate}\right)\div\text{vbv-bufsize} \times \text{fps} \right) \)</span> 中最小的值作为检索帧数</p>
            <!-- } -->
            <code><b>--no-mbtree</b></code>
            <p class="font-monospace pl-5 m-0 overflow-auto">&lt;开关&gt; 关闭少见宏块量化偏移。可能只有近无损，<code>--crf</code> 小于 16 才用的到。</p>

            <h2 id="h2-13">熵编码/文本压缩</h2>
            <p>x264 教程中仅提及最简单的形式。完成的熵编码流程见 <a href="../../x265-web-tutorial/HTML/index.html#h2-15">x265 教程网页版 - 熵编码</a>。</p>
            
            <h3>霍夫曼编码 Huffman Coding</h3>
            <p>曾经广泛应用于数据压缩的算法。步骤分为：</p>
            <ol>
                <li><b>统计频率</b>：
                    <ul>
                        <li>在第一次遍历文本/pass1 时，只统计每个字符出现的次数，并按出现频率从小到大排序</li>
                    </ul>
                </li>
                <li><b>构建初始节点</b>：
                    <ul>
                        <li>将每个字符和其出现频率作为一个节点，并将这些节点放入一个最小堆（优先队列）</li>
                    </ul>
                </li>
                <li><b>构建霍夫曼树</b>：
                    <ul>
                        <li>从最小堆中取出两个频率最小的节点</li>
                        <li>创建一个新节点，其频率是这两个节点频率之和，将这两个节点作为新节点的子节点</li>
                        <li>将新节点插回最小堆中</li>
                        <li>重复上述步骤，直到堆中只剩下一个节点，这个节点就是霍夫曼树的根节点</li>
                    </ul>
                </li>
                <li><b>生成编码</b>：
                    <ul>
                        <li>通过遍历霍夫曼树，为每个字符生成霍夫曼编码。通常向左的节点表示为向 0，向右的节点表示为向 1</li>
                    </ul>
                </li>
            </ol>

            <h4>霍夫曼编码例</h4>
            <p>来源：<a href="https://www.geeksforgeeks.org/huffman-coding-greedy-algo-3/">geekforgeeks - greedy3</a> 算法。假设第一次遍历文本得到了如下字符及其频率：</p>

            <table class="table-center align-items-center">
                <thead>
                    <th class="px-3">字符</th><th class="px-3">频率</th>
                </thead>
                <tbody>
                    <tr class="border-bottom">
                        <td>A</td><td>5</td>
                    </tr>
                    <tr class="border-bottom">
                        <td>B</td><td>9</td>
                    </tr>
                    <tr class="border-bottom">
                        <td>C</td><td>12</td>
                    </tr>
                    <tr class="border-bottom">
                        <td>D</td><td>13</td>
                    </tr>
                    <tr class="border-bottom">
                        <td>E</td><td>16</td>
                    </tr>
                    <tr>
                        <td>F</td><td>45</td>
                    </tr>
                </tbody>
            </table>
            <ol>
                <li><b>统计频率</b>：已完成</li>
                <li><b>构建初始节点</b>：
                    <ul>
                        <li>据出字次数从小到大排序：<span class="text-blue-math">(5,'a'),(9,'b'),(12,'c'),(13,'d'),(16,'e'),(45,'f')</span></li>
                    </ul>
                </li>
                <li><b>构建霍夫曼树</b>：
                    <ol>
                        <li>取出字次数最小的两个元素 (5, 'a'), (9, 'b')，合为 (14, 'ab')
                            <ul class="text-smaller">
                                <li>得 (12, 'c'), (13, 'd'), (16, 'e'), (45, 'f'), (14, 'ab')</li>
                                <li><img src="files/huffman-coding/1.png" alt="image31" class="img-small" ></li>
                            </ul>
                        </li>
                        <li>取出字次数最小的两个元素 (12, 'c'), (13, 'd')，合并为 (25, 'cd')
                            <ul class="text-smaller">
                                <li>得 (14, 'ab'), (16, 'e'), (45, 'f'), (25, 'cd')</li>
                                <li><img src="files/huffman-coding/2.png" alt="image32" class="img-small" ></li>
                            </ul>
                        </li>
                        <li>取出字次数最小的两个元素 (14, 'ab'), (16, 'e')，合并为 (30, 'abe')
                            <ul class="text-smaller">
                                <li>得 (25, 'cd'), (45, 'f'), (30, 'abe')</li>
                                <li><img src="files/huffman-coding/3.png" alt="image33" class="img-medium" ></li>
                            </ul>
                        </li>
                        <li>取出字次数最小的两个元素 (25, 'cd'), (30, 'abe')，合并为 (55, 'cdeab')
                            <ul class="text-smaller">
                                <li>得 (45, 'f'), (55, 'CDEAB')</li>
                                <li><img src="files/huffman-coding/4.png" alt="image34" class="img-medium" ></li>
                            </ul>
                        </li>
                        <li>取出字次数最小的两个元素 (45, 'f'), (55, 'cdeab')，合并为 (100, 'fcdeab')
                            <ul class="text-smaller">
                                <li>得 (100, 'FCDEAB')</li>
                                <li><img src="files/huffman-coding/5.png" alt="image35" class="img-medium" ></li>
                            </ul>
                        </li>
                    </ol>
                </li>
                <li><b>生成编码</b>：
                    <ul>
                        <li>从霍夫曼树根节点开始，为每个字符生成霍夫曼编码：</li>
                    </ul>
                </li>
            </ol>
            <table class="table-center align-items-center">
                <thead>
                    <th class="px-3">字符</th><th class="px-3">编码</th>
                </thead>
                <tbody>
                    <tr class="border-bottom">
                        <td>F</td><td>0</td>
                    </tr>
                    <tr class="border-bottom">
                        <td>C</td><td>1-0-0</td>
                    </tr>
                    <tr class="border-bottom">
                        <td>D</td><td>1-0-1</td>
                    </tr>
                    <tr class="border-bottom">
                        <td>A</td><td>1-1-0-0</td>
                    </tr>
                    <tr class="border-bottom">
                        <td>B</td><td>1-1-0-1</td>
                    </tr>
                    <tr>
                        <td>E</td><td>1-1-1</td>
                    </tr>
                </tbody>
            </table>

            <p>------------------------未完成内容------------------------</p>
            <h3>测试 - 成功：</h3>
            <p><a href="../../x265-web-tutorial/HTML/index.html">交叉（../../）打开 x265 教程网页版</a></p>

            <h3>测试 - 成功：</h3>
            <p>直接跳转到<a href="../../x265-web-tutorial/HTML/index.html#h2-5">x265 教程 - 动态搜索</a></p>

            <h3>下载 x264 GUI</h3>
            <table class="table-center">
                <tbody>
                    <tr class="border-bottom">
                        <th class="t-light-gray"><a href="https://shana.pe.kr/shanaencoder_download">ShanaEncoder</a></th>
                        <td class="px-1">ffmpeg-CLI 搭配部分 GUI，上手需要时间。ffmpeg 内嵌编码器，不能替换文件</td>
                    </tr>
                    <tr class="border-bottom">
                        <th class="t-light-gray"><a href="https://bitbucket.org/muldersoft/simple-x264-launcher/downloads/">Simple x264 Launcher</a></th>
                        <td class="px-1">英文软件，适合批量压制，需自行封装音频。只能压视频</td>
                    </tr>
                    <tr>
                        <th class="t-light-gray">小丸工具箱</th>
                        <td class="px-1">操作简单，适合入门的中文软件。网上能搜到详细教程。内嵌 MediaInfo，mp4box，Mkvtoolnix。镜像：<a href="https://pan.baidu.com/s/1VHonGHoZ0DmQBNZaRjML2A&pwd=crhu">百度云</a> 提取码"crhu"</td>
                    </tr>
                </tbody>
            </table>
            
            <h3>下载基本工具</h3>
            <table class="table-center">
                <tbody>
                    <tr class="border-bottom">
                        <th class="px-3 t-light-gray"><a href="http://ffmpeg.org/download.html">ffmpeg</a></th>
                        <td class="px-1">强大的 CLI 开源视音频处理工具</td>
                    </tr>
                    <tr class="border-bottom">
                        <th class="px-3 t-light-gray"><a href="https://mpv.io/installation/">mpv</a></th>
                        <td class="px-1">开源，支持便携的现代视频播放器。见<a href="https://nazorip.site/archives/1052/">安装与配置</a>教程</td>
                    </tr>
                    <tr class="border-bottom">
                        <th class="px-3 t-light-gray"><a href="https://www.voukoder.org/">Voukoder</a></th>
                        <td class="px-1">开源 Premiere Vegas After Effects 压制导出插件，分为 Voukoder 和 V-Connector 两部分</td>
                    </tr>
                    <tr class="border-bottom">
                        <th class="px-3 t-light-gray"><a href="https://obsproject.com/zh-cn/download">OBS</a></th>
                        <td class="px-1">强大的开源直播框架和软件，设置略比传统录屏软件复杂，但效果也更好</td>
                    </tr>
                    <tr class="border-bottom">
                        <th class="px-3 t-light-gray"><a href="https://mediaarea.net/zh-CN/MediaInfo">MediaInfo</a></th>
                        <td class="px-1">开源的 GUI 媒体元数据/视音频格式读取器，用于配置正确的压制参数</td>
                    </tr>
                    <tr>
                        <th class="px-3 t-light-gray"><a href="http://ffmpeg.org/download.html">ffprobe</a></th>
                        <td class="px-1">CLI 视音频格式读取器，若检测所得信息与 MediaInfo 所异，则优先参考 ffprobe<br>见<a href="https://nazorip.site/archives/169/">基本使用</a>，以及<a href="https://nazorip.site/archives/1068/">搭配 Excel 的视频数据可视化</a>教程
                        </td>
                    </tr>
                </tbody>
            </table>

            <h3>下载 x264</h3>
            <table class="table-center">
                <tbody>
                    <tr class="border-bottom">
                        <th class="px-3 t-light-gray"><a href="https://www.mediafire.com/folder/arv5xmdqyiczc">Patman</a></th>
                        <td class="px-1">支持 Lavf 编解码 [8~10bit]</td>
                    </tr>
                    <tr class="border-bottom">
                        <th class="px-3 t-light-gray"><a href="https://www.mediafire.com/?bxvu1vvld31k1">LigH</a></th>
                        <td class="px-1">支持 Lavf 编解码 [8~10bit]</td>
                    </tr>
                    <tr class="border-bottom">
                        <th class="px-3 t-light-gray"><a href="https://github.com/jpsdr/x264/releases/">jspdr (tMod)</a></th>
                        <td class="px-1">支持 Lavf 编解码，MCF 线程管理库</td>
                    </tr>
                    <tr>
                        <th class="px-3 t-light-gray">x264 7mod</th>
                        <td class="px-1">支持 Lavf 编解码，支持 hqdn3d 降噪，镜像链接：<a href="https://drive.google.com/drive/folders/1kFCeNGA_wiiLt-DSeI3cyY8vxlffgQcy?usp=sharing">谷歌盘</a>/<a href="https://pan.baidu.com/s/1sbz8WztGTz3lcLzirHW_2w">百度云</a></td>
                    </tr>
                </tbody>
            </table>
        </div>
        <!-- Footer -->
        <footer class="py-3 my-4 align-items-center border-top">
            <p>联系：
                <a href='https://github.com/iAvoe/'>Github</a>，
                <a href='https://jq.qq.com/?_wv=1027&k=5YJFXyf'>QQ 群：691892901</a>
            </p>
            &#x24B8; iAvoe，2024
        </footer>
	</body>
</html>